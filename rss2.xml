<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LoveOps</title>
    <link>http://blog.loveops.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Good Good Study！Day Day Up！</description>
    <pubDate>Thu, 28 Dec 2017 07:19:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Kubernetes集群部署之flannel</title>
      <link>http://blog.loveops.com/2017/12/28/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B9%8Bflannel/</link>
      <guid>http://blog.loveops.com/2017/12/28/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B9%8Bflannel/</guid>
      <pubDate>Thu, 28 Dec 2017 07:16:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;系统版本&lt;/th&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><table><thead><tr><th>IP地址</th><th>系统版本</th><th>主机名</th><th>角色</th></tr></thead><tbody><tr><td>172.16.1.2/24</td><td>Ubuntu 16.04.2 LTS</td><td>k8s-master</td><td>Kubernetes-master/Kubernetes-node/etcd/flannel</td></tr><tr><td>172.16.1.6/24</td><td>Ubuntu 16.04.2 LTS</td><td>k8s-node1</td><td>Kubernetes-node/etcd/flannel</td></tr><tr><td>172.16.1.7/24</td><td>Ubuntu 16.04.2 LTS</td><td>k8s-node2</td><td>Kubernetes-node/etcd/flannel</td></tr></tbody></table><h3 id="在etcd中设置-flannel节点所使用的IP段-（只需要一个节点执行接口）"><a href="#在etcd中设置-flannel节点所使用的IP段-（只需要一个节点执行接口）" class="headerlink" title="在etcd中设置 flannel节点所使用的IP段 （只需要一个节点执行接口）"></a>在etcd中设置 flannel节点所使用的IP段 （只需要一个节点执行接口）</h3><p>在上篇文章中，我们已经介绍了etcd集群的搭建。而flannel需要用到etcd，首先我们需要把网络配置放入etcd中：（注意：我们这里虽然etcd版本是3.2.11，但是flannel不支持v3的api，所以需要用v2的api，/coreos.com/network/config是etcd默认存储路径，也可以自己设定）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-node1:~# etcdctl -version</span><br><span class="line">etcdctl version: 3.2.11</span><br><span class="line">API version: 2</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ENDPOINTS</span>=http://172.16.1.2:2379,http://172.16.1.6:2379,http://172.16.1.7:2379</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ETCDCTL_API</span>=2</span><br><span class="line"></span><br><span class="line">etcdctl <span class="attribute">--endpoints</span>=<span class="variable">$ENDPOINTS</span> <span class="builtin-name">set</span> /coreos.com/network<span class="built_in">/config </span>&lt; config.json  </span><br><span class="line"></span><br><span class="line">config.json内容：</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Network"</span>: <span class="string">"10.0.0.0/8"</span>,</span><br><span class="line">    <span class="string">"SubnetMin"</span>: <span class="string">"10.10.0.0"</span>,</span><br><span class="line">    <span class="string">"SubnetMax"</span>: <span class="string">"10.99.0.0"</span>,</span><br><span class="line">    <span class="string">"Backend"</span>: &#123;</span><br><span class="line">        <span class="string">"Type"</span>: <span class="string">"vxlan"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~# etcdctl <span class="attribute">--endpoints</span>=<span class="variable">$ENDPOINTS</span> <span class="builtin-name">get</span> /coreos.com/network/config</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Network"</span>: <span class="string">"10.0.0.0/8"</span>,</span><br><span class="line">    <span class="string">"SubnetMin"</span>: <span class="string">"10.10.0.0"</span>,</span><br><span class="line">    <span class="string">"SubnetMax"</span>: <span class="string">"10.99.0.0"</span>,</span><br><span class="line">    <span class="string">"Backend"</span>: &#123;</span><br><span class="line">        <span class="string">"Type"</span>: <span class="string">"vxlan"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flannel支持不同的backend，一旦设定，在运行时是不能更改的。flannel支持的backend有如下集中，vxlan是官方建议的。"><a href="#flannel支持不同的backend，一旦设定，在运行时是不能更改的。flannel支持的backend有如下集中，vxlan是官方建议的。" class="headerlink" title="flannel支持不同的backend，一旦设定，在运行时是不能更改的。flannel支持的backend有如下集中，vxlan是官方建议的。"></a>flannel支持不同的backend，一旦设定，在运行时是不能更改的。flannel支持的backend有如下集中，vxlan是官方建议的。</h4><ul><li>vxlan</li><li>udp</li><li>host-gw</li></ul><h3 id="flannel安装"><a href="#flannel安装" class="headerlink" title="flannel安装"></a>flannel安装</h3><p>flannel安装比较简单，直接下载相应的版本，然后把二进制和mk-docker-opts.sh两个文件拷贝到PATH变量路径即可。</p><ul><li>flannel 版本</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="symbol">@k8s</span>-master:~<span class="meta"># flanneld  -version</span></span><br><span class="line">v0<span class="number">.9</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><ul><li><p>flannel 启动（三个节点都要安装启动，启动命令一样）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flanneld <span class="attribute">-etcd-endpoints</span>=<span class="string">"http://172.16.1.2:2379,http://172.16.1.6:2379,http://172.16.1.7:2379"</span> <span class="attribute">-etcd-prefix</span>=/coreos.com/network</span><br></pre></td></tr></table></figure></li><li><p>flannel 启动参数介绍</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-public-ip =“”：其他节点可以通过IP进行主机间通信。默认为用于通信的接口的IP。</span></span><br><span class="line"><span class="ruby">--etcd-endpoints = <span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:4001：以逗号分隔的etcd端点列表。</span></span></span><br><span class="line"><span class="ruby">--etcd-prefix = <span class="regexp">/coreos.com/network</span>：etcd前缀。</span></span><br><span class="line"><span class="ruby">--etcd-keyfile =“”：用于保护etcd通信的SSL密钥文件。</span></span><br><span class="line"><span class="ruby">--etcd-certfile =“”：用于保护etcd通信的SSL认证文件。</span></span><br><span class="line"><span class="ruby">--etcd-cafile =“”：用于保护etcd通信的SSL证书颁发机构文件。</span></span><br><span class="line"><span class="ruby">--kube-subnet-mgr：联系Kubernetes API进行子网分配而不是etcd。</span></span><br><span class="line"><span class="ruby">--iface = “”：使用（IP或名称）进行主机间通信的接口。默认为机器上默认路由的接口。这可以指定多次，以检查每个选项的顺序。返回找到的第一个匹配项。</span></span><br><span class="line"><span class="ruby">--iface-regex =“”：正则表达式匹配第一个使用（IP或名字）进行主机间通信的接口。如果未指定，则默认为机器上默认路由的接口。这可以指定多次，以检查每个正则表达式。返回找到的第一个匹配项。此选项被iface选项取代，只有在iface选项中指定的选项没有任何匹配时才会使用该选项。</span></span><br><span class="line"><span class="ruby">--subnet-file = <span class="regexp">/run/flannel</span><span class="regexp">/subnet.env：filename其中env变量（子网和MTU值）将被写入。</span></span></span><br><span class="line"><span class="ruby">--subnet-lease-renew-margin = <span class="number">60</span>：子网租约更新余量，以分钟为单位。</span></span><br><span class="line"><span class="ruby">--ip-masq = <span class="literal">false</span>：设置目的地为f网络之外的流量的IP伪装。 Flannel假定NAT POSTROUTING链中的默认策略是ACCEPT。</span></span><br><span class="line"><span class="ruby">-v = <span class="number">0</span>：V日志的日志级别。设置为<span class="number">1</span>以查看与数据路径相关的消息。</span></span><br><span class="line"><span class="ruby">--healthz-ip =“<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>”：healthz服务器侦听的IP地址（默认为“<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>”）</span></span><br><span class="line"><span class="ruby">--healthz-port = <span class="number">0</span>：healthz服务器侦听的端口（<span class="number">0</span>表示禁用）</span></span><br><span class="line"><span class="ruby">- version：打印版本并退出</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="修改docker启动参数-三个几点都操作"><a href="#修改docker启动参数-三个几点都操作" class="headerlink" title="修改docker启动参数(三个几点都操作)"></a>修改docker启动参数(三个几点都操作)</h3><p>flannel启动后，会从etcd获取配置信息，然后划分subnet，并在etcd中注册，然后将子网信息写入到/run/flannel/subnet.env</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">root@k8s-node1:~# cat  /var/run/flannel/subnet.env</span></span><br><span class="line">FLANNEL_NETWORK=10.0.0.0/8</span><br><span class="line">FLANNEL_SUBNET=10.10.40.1/24</span><br><span class="line">FLANNEL_MTU=1450</span><br><span class="line">FLANNEL_IPMASQ=false</span><br></pre></td></tr></table></figure><p>创建docker启动参数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker</span><br><span class="line"></span><br><span class="line"><span class="section">root@k8s-node1:~# cat /run/flannel/docker</span></span><br><span class="line">DOCKER_OPT_BIP=<span class="string">"--bip=10.10.40.1/24"</span></span><br><span class="line">DOCKER_OPT_IPMASQ=<span class="string">"--ip-masq=true"</span></span><br><span class="line">DOCKER_OPT_MTU=<span class="string">"--mtu=1450"</span></span><br><span class="line">DOCKER_NETWORK_OPTIONS=<span class="string">" --bip=10.10.40.1/24 --ip-masq=true --mtu=1450"</span></span><br></pre></td></tr></table></figure><p>修改启动参数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">root@k8s-node1:~# cat  /lib/systemd/system/docker.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target docker.socket firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="comment"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class="line"><span class="comment"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class="line"><span class="comment"># for containers run by docker</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd://  --bip=10.10.40.1/24 --ip-masq=true --mtu=1450</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line"><span class="comment"># Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="comment"># in the kernel. We recommend using cgroups to do container-local accounting.</span></span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="comment"># Uncomment TasksMax if your systemd version supports it.</span></span><br><span class="line"><span class="comment"># Only systemd 226 and above support this version.</span></span><br><span class="line">TasksMax=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"><span class="comment"># set delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line">Delegate=yes</span><br><span class="line"><span class="comment"># kill only the docker process, not all processes in the cgroup</span></span><br><span class="line">KillMode=process</span><br><span class="line"><span class="comment"># restart the docker process if it exits prematurely</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>重启docker进程：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-node1:~<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">root@k8s-node1:~<span class="comment"># systemctl restart docker.service</span></span><br><span class="line">root@k8s-node1:~<span class="comment"># ps -ef | grep -v grep | grep dockerd</span></span><br><span class="line">root      <span class="number">6228</span>     <span class="number">1</span>  <span class="number">0</span> Dec27 ?        <span class="number">00</span>:<span class="number">03</span>:<span class="number">09</span> /usr<span class="regexp">/bin/dockerd -H fd:/</span>/ --bip=<span class="number">10.10</span><span class="number">.40</span><span class="number">.1</span>/<span class="number">24</span> --ip-masq=<span class="literal">true</span> --mtu=<span class="number">1450</span></span><br></pre></td></tr></table></figure><h3 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h3><p>上面我们把flannel搭建起来了。现在测试下网络连通性</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~<span class="comment"># etcdctl --endpoints=$ENDPOINTS ls /coreos.com/network/subnets</span></span><br><span class="line"><span class="regexp">/coreos.com/</span>network<span class="regexp">/subnets/</span><span class="number">10.10</span>.<span class="number">95.0</span>-<span class="number">24</span></span><br><span class="line"><span class="regexp">/coreos.com/</span>network<span class="regexp">/subnets/</span><span class="number">10.10</span>.<span class="number">50.0</span>-<span class="number">24</span></span><br><span class="line"><span class="regexp">/coreos.com/</span>network<span class="regexp">/subnets/</span><span class="number">10.10</span>.<span class="number">40.0</span>-<span class="number">24</span></span><br></pre></td></tr></table></figure><p>可以看到三台分配的子网，我们可以在主机上直接ping通容器网络。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~#<span class="built_in"> ping </span>-c 2 10.10.40.2</span><br><span class="line">PING 10.10.40.2 (10.10.40.2) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.10.40.2: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=63 <span class="attribute">time</span>=0.699 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.10.40.2: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=63 <span class="attribute">time</span>=0.661 ms</span><br><span class="line"></span><br><span class="line">--- 10.10.40.2<span class="built_in"> ping </span>statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.661/0.680/0.699/0.019 ms</span><br><span class="line">root@k8s-master:~#<span class="built_in"> ping </span>-c 2 10.10.50.2</span><br><span class="line">PING 10.10.50.2 (10.10.50.2) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.10.50.2: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.151 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.10.50.2: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.054 ms</span><br><span class="line"></span><br><span class="line">--- 10.10.50.2<span class="built_in"> ping </span>statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.054/0.102/0.151/0.049 ms</span><br><span class="line"></span><br><span class="line">root@k8s-master:~#<span class="built_in"> ping </span>-c 2 10.10.95.1</span><br><span class="line">PING 10.10.95.1 (10.10.95.1) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.10.95.1: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.490 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.10.95.1: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.458 ms</span><br><span class="line"></span><br><span class="line">--- 10.10.95.1<span class="built_in"> ping </span>statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.458/0.474/0.490/0.016 ms</span><br></pre></td></tr></table></figure><p>跨主机容器也是可以，这里不在测试。</p><h3 id="flannel实现"><a href="#flannel实现" class="headerlink" title="flannel实现"></a>flannel实现</h3><p>flannel网络拓扑图如下：(下图是upd是示意图，vxlan基本类似)<br><img src="/images/flannel.png" alt=""><br>在k8s-master查看路由表，到容器网络10.10.40.0/24 和 10.10.95.0/24 的数据包会发送到flannel.1，flannel.1将数据封装成vxlan，通过网卡eth发送另外主机</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~# <span class="built_in">ip</span> r</span><br><span class="line"><span class="meta">default</span> via <span class="number">172.16</span><span class="meta">.1</span><span class="meta">.1</span> dev eth0</span><br><span class="line"><span class="number">10.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">8</span> dev flannel<span class="meta">.1</span></span><br><span class="line"><span class="number">10.10</span><span class="meta">.40</span><span class="meta">.0</span>/<span class="number">24</span> via <span class="number">10.10</span><span class="meta">.40</span><span class="meta">.0</span> dev flannel<span class="meta">.1</span> onlink</span><br><span class="line"><span class="number">10.10</span><span class="meta">.50</span><span class="meta">.0</span>/<span class="number">24</span> dev docker0  proto kernel  scope link  src <span class="number">10.10</span><span class="meta">.50</span><span class="meta">.1</span></span><br><span class="line">c via <span class="number">10.10</span><span class="meta">.95</span><span class="meta">.0</span> dev flannel<span class="meta">.1</span> onlink</span><br><span class="line"><span class="number">172.16</span><span class="meta">.1</span><span class="meta">.0</span>/<span class="number">24</span> dev eth0  proto kernel  scope link  src <span class="number">172.16</span><span class="meta">.1</span><span class="meta">.2</span></span><br><span class="line"><span class="number">172.18</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">16</span> dev docker_gwbridge  proto kernel  scope link  src <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.1</span> linkdown</span><br></pre></td></tr></table></figure><p>flannel网络中容器与外网联通的方式与bridge一样，也是通过nat方式。</p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/28/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B9%8Bflannel/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Kubernetes集群部署之etcd</title>
      <link>http://blog.loveops.com/2017/12/25/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B9%8Betcd/</link>
      <guid>http://blog.loveops.com/2017/12/25/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B9%8Betcd/</guid>
      <pubDate>Mon, 25 Dec 2017 11:44:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerlink&quot; title=&quot;总体介绍&quot;&gt;&lt;/a&gt;总体介绍&lt;/h3&gt;&lt;p&gt;Kubernetes是一个开源平台，旨在自动部署，扩展和运行应用程序容器。&lt;/p&gt;
&lt;p&gt;通过Kubernetes，您可以快
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>Kubernetes是一个开源平台，旨在自动部署，扩展和运行应用程序容器。</p><p>通过Kubernetes，您可以快速高效地响应客户需求：</p><ul><li>快速和可预测地部署您的应用程序。</li><li>随时扩展您的应用程序。</li><li>无缝地推出新功能。</li><li>仅限硬件使用情况为所需资源。</li></ul><p>我们的目标是建立一个组件和工具的生态系统，减轻在公共和私有云中运行应用程序的负担。</p><p>Kubernetes特点：</p><ul><li>便携式：公共，私人，混合，多云</li><li>可扩展：模块化，可插拔，可挂接，可组合</li><li>自我修复：自动放置，自动重启，自动复制，自动缩放</li></ul><p>Google在2014年启动了Kubernetes项目.Kubernetes建立在Google大规模运行生产工作量的十五年经验的基础上，结合社区最佳的创意和实践。</p><p>从本篇文章开始我们将部署一步一步部署k8s集群。由于k8s的网络我认为是比较复杂的，我们就从网络开始。k8s默认的网络为flannel，那么我们就从flannel开始，由于flannel需要etcd的支持，我们本篇文章就先介绍etcd。</p><h3 id="etcd介绍"><a href="#etcd介绍" class="headerlink" title="etcd介绍"></a>etcd介绍</h3><p>etcd是一个开源的分布式键值存储，提供了一个可靠的方式来存储跨机器集群的数据。 etcd在网络分区时优雅地处理领导选举，并容忍包括领导在内的机器故障。</p><p>您的应用程序可以读取和写入数据到etcd。 一个简单的用例是将数据库连接详细信息或功能标志作为关键值对存储在etcd中。 可以监视这些值，允许您的应用在更改时自行重新配置。</p><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><table><thead><tr><th>IP地址</th><th>系统版本</th><th>主机名</th><th>角色</th></tr></thead><tbody><tr><td>172.16.1.2/24</td><td>Ubuntu 16.04.2 LTS</td><td>k8s-master</td><td>Kubernetes-master/Kubernetes-node/etcd/flannel</td></tr><tr><td>172.16.1.6/24</td><td>Ubuntu 16.04.2 LTS</td><td>k8s-node1</td><td>Kubernetes-node/etcd/flannel</td></tr><tr><td>172.16.1.7/24</td><td>Ubuntu 16.04.2 LTS</td><td>k8s-node2</td><td>Kubernetes-node/etcd/flannel</td></tr></tbody></table><h3 id="etcd安装"><a href="#etcd安装" class="headerlink" title="etcd安装"></a>etcd安装</h3><p>etcd是有go语言编写的，我们直接下载编译好的二进制文件即可，下载解压后有两个二进制文件etcd和etcdctl。把这两个文件放入/usr/local/sbin即可。我们这里采用的版本如下：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root@k8s-node1:~# etcd -version</span></span><br><span class="line"><span class="attribute">etcd Version</span>: 3.2.11</span><br><span class="line"><span class="attribute">Git SHA</span>: 1e1dbb2</span><br><span class="line"><span class="attribute">Go Version</span>: go1.8.5</span><br><span class="line"><span class="attribute">Go OS/Arch</span>: linux/amd64</span><br></pre></td></tr></table></figure><h3 id="启动etcd集群"><a href="#启动etcd集群" class="headerlink" title="启动etcd集群"></a>启动etcd集群</h3><ul><li><p>k8s-master</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etcd <span class="params">--data-dir=/var/lib/etcd</span> <span class="params">--name</span> etcd_one \</span><br><span class="line"><span class="params">--initial-advertise-peer-urls</span> http:<span class="string">//172.16.1.2</span><span class="function">:2380</span> <span class="params">--listen-peer-urls</span> http:<span class="string">//172.16.1.2</span><span class="function">:2380</span> \</span><br><span class="line"><span class="params">--advertise-client-urls</span> http:<span class="string">//172.16.1.2</span><span class="function">:2379</span> <span class="params">--listen-client-urls</span> http:<span class="string">//172.16.1.2</span><span class="function">:2379</span> \</span><br><span class="line"><span class="params">--initial-cluster</span> etcd_one=http:<span class="string">//172.16.1.2</span><span class="function">:2380</span>,etcd_two=http:<span class="string">//172.16.1.6</span><span class="function">:2380</span>,etcd_thr=http:<span class="string">//172.16.1.7</span><span class="function">:2380</span> \</span><br><span class="line"><span class="params">--initial-cluster-state</span> new <span class="params">--initial-cluster-token</span>  test-token</span><br></pre></td></tr></table></figure></li><li><p>k8s-node1</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etcd <span class="params">--data-dir=/var/lib/etcd</span> <span class="params">--name</span> etcd_two \</span><br><span class="line"><span class="params">--initial-advertise-peer-urls</span> http:<span class="string">//172.16.1.6</span><span class="function">:2380</span> <span class="params">--listen-peer-urls</span> http:<span class="string">//172.16.1.6</span><span class="function">:2380</span> \</span><br><span class="line"><span class="params">--advertise-client-urls</span> http:<span class="string">//172.16.1.6</span><span class="function">:2379</span> <span class="params">--listen-client-urls</span> http:<span class="string">//172.16.1.6</span><span class="function">:2379</span> \</span><br><span class="line"><span class="params">--initial-cluster</span> etcd_one=http:<span class="string">//172.16.1.2</span><span class="function">:2380</span>,etcd_two=http:<span class="string">//172.16.1.6</span><span class="function">:2380</span>,etcd_thr=http:<span class="string">//172.16.1.7</span><span class="function">:2380</span> \</span><br><span class="line"><span class="params">--initial-cluster-state</span> new <span class="params">--initial-cluster-token</span> test-token</span><br></pre></td></tr></table></figure></li><li><p>k8s-node2</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etcd <span class="params">--data-dir=/var/lib/etcd</span> <span class="params">--name</span> etcd_thr \</span><br><span class="line"><span class="params">--initial-advertise-peer-urls</span> http:<span class="string">//172.16.1.7</span><span class="function">:2380</span> <span class="params">--listen-peer-urls</span> http:<span class="string">//172.16.1.7</span><span class="function">:2380</span> \</span><br><span class="line"><span class="params">--advertise-client-urls</span> http:<span class="string">//172.16.1.7</span><span class="function">:2379</span> <span class="params">--listen-client-urls</span> http:<span class="string">//172.16.1.7</span><span class="function">:2379</span> \</span><br><span class="line"><span class="params">--initial-cluster</span> etcd_one=http:<span class="string">//172.16.1.2</span><span class="function">:2380</span>,etcd_two=http:<span class="string">//172.16.1.6</span><span class="function">:2380</span>,etcd_thr=http:<span class="string">//172.16.1.7</span><span class="function">:2380</span> \</span><br><span class="line"><span class="params">--initial-cluster-state</span> new <span class="params">--initial-cluster-token</span> test-token</span><br></pre></td></tr></table></figure><p>注意: –initial-cluster 可以直接指定列表意外，还可以用–discovery具体参考官方文档：<br><a href="https://coreos.com/etcd/docs/latest/op-guide/clustering.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/op-guide/clustering.html</a></p><p>安装完成后可以验证：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~# export ETCDCTL<span class="emphasis">_API=3</span></span><br><span class="line"><span class="emphasis">root@k8s-master:~# export ENDPOINTS=172.16.1.2:2379,172.16.1.6:2379,172.16.1.7:2379</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">root@k8s-master:~# etcdctl  --endpoints=$ENDPOINTS --write-out=table member list</span></span><br><span class="line"><span class="emphasis">+------------------+---------+----------+------------------------+------------------------+</span></span><br><span class="line"><span class="emphasis">|        ID        | STATUS  |   NAME   |       PEER ADDRS       |      CLIENT ADDRS      |</span></span><br><span class="line"><span class="emphasis">+------------------+---------+----------+------------------------+------------------------+</span></span><br><span class="line"><span class="emphasis">|  81555da054c53f2 | started | etcd_</span>one | http://172.16.1.2:2380 | http://172.16.1.2:2379 |</span><br><span class="line">| d26140195b4d1493 | started | etcd<span class="emphasis">_two | http://172.16.1.6:2380 | http://172.16.1.6:2379 |</span></span><br><span class="line"><span class="emphasis">| ffd1352eadf95c93 | started | etcd_</span>two | http://172.16.1.7:2380 | http://172.16.1.7:2379 |</span><br><span class="line"><span class="code">+------------------+</span>---------<span class="code">+----------+</span>------------------------<span class="code">+------------------------+</span></span><br></pre></td></tr></table></figure><h3 id="启动参数说明"><a href="#启动参数说明" class="headerlink" title="启动参数说明"></a>启动参数说明</h3><ul><li>-name  </li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： <span class="type">ETCD_NAME</span> </span><br><span class="line">成员的可读名称，默认是<span class="keyword">default</span></span><br></pre></td></tr></table></figure><ul><li>-data-dir </li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_DAT<span class="built_in">A_DIR</span> </span><br><span class="line">数据目录，默认是<span class="string">"$&#123;name&#125;.etcd"</span></span><br></pre></td></tr></table></figure><ul><li>-wal-dir                     </li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_WAL_DIR<span class="string">| </span></span><br><span class="line">专用wal目录的路径。 如果这个标志被设置，</span><br><span class="line">etcd会将WAL文件写入walDir而不是dataDir。 这允许使用专用磁盘，并有助于避免记录和其他IO操作之间的竞争。默认是空</span><br></pre></td></tr></table></figure><ul><li>–snapshot-count       </li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_SNAPSHOT_COUNT </span><br><span class="line">触发快照到磁盘的已提交事务的数量。默认是<span class="number">10000</span></span><br></pre></td></tr></table></figure><ul><li>–heartbeat-interval </li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_HEARTBEAT_INTERVAL</span><br><span class="line">心跳间隔的时间（以毫秒为单位）默认是<span class="number">100</span>ms</span><br></pre></td></tr></table></figure><ul><li>–election-timeout            </li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_ELECTION_TIMEOUT</span><br><span class="line">选举超时的时间（以毫秒为单位）默认是<span class="number">1000</span>ms</span><br></pre></td></tr></table></figure><ul><li>–listen-peer-urls           </li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_LISTEN_PEER_URLS</span><br><span class="line">监听对等流量的<span class="built_in">URL</span>列表。 这个标志告诉etcd在指定的scheme://IP:port 组合上接受来自其对端的传入请求。 Scheme可以是<span class="keyword">http</span>或<span class="keyword">https</span>。如果指定IP为<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>，则etcd监听所有接口上的给定端口。 如果IP地址和端口一样，etcd将监听给定的端口和接口。 可以使用多个<span class="built_in">URL</span>来指定要监听的地址和端口的数量。 etcd将响应来自任何列出的地址和端口的请求。默认是<span class="keyword">http</span>://localhost:<span class="number">2380</span> |</span><br></pre></td></tr></table></figure><ul><li>–listen-client-urls          </li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_LISTEN_CLIENT_URLS</span><br><span class="line">要监听客户端流量的URL列表。 该标志告诉etcd接受来自指定方案的客户端的传入请求：scheme//<span class="built_in">IP</span>:port。 Scheme可以是http或https。 如果指定<span class="built_in">IP</span>为<span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>，则etcd监听所有接口上的给定端口。 如果<span class="built_in">IP</span>地址和端口一样，etcd将监听给定的端口和接口。 可以使用多个URL来指定要监听的地址和端口的数量。 etcd将响应来自任何列出的地址和端口的请求。默认是http://localhost:<span class="number">2379</span></span><br></pre></td></tr></table></figure><ul><li>–max-snapshots               </li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_MAX_SNAPSHOTS</span><br><span class="line">保留的最大快照文件数量（<span class="number">0</span>无限制）默认是<span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>–max-wals     </li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_MAX_WALS</span><br><span class="line">要保留的最大wal文件数（<span class="number">0</span>是无限的）默认是<span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>–cors                        </li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_CORS  </span><br><span class="line">用逗号分隔的CORS起源白名单（跨源资源共享）。默认是<span class="keyword">none</span></span><br></pre></td></tr></table></figure><p>–initial-advertise-peer-urls </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_INITIAL_ADVERTISE_PEER_URLS </span><br><span class="line">此成员的对等<span class="built_in">URL</span>列表以通告给群集的其余部分。 这些地址用于在集群周围传送etcd数据。 至少有一个必须可路由到所有集群成员。 这些<span class="built_in">URL</span>可以包含域名。默认是<span class="keyword">http</span>://localhost:<span class="number">2380</span></span><br></pre></td></tr></table></figure><ul><li>–initial-cluster            </li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_INITIAL_CLUSTER </span><br><span class="line">引导的初始群集配置。默认是<span class="keyword">default</span>=<span class="string">http:</span><span class="comment">//localhost:2380</span></span><br></pre></td></tr></table></figure><ul><li>–initial-cluster-state</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_INITIAL_CLUSTER_STATE </span><br><span class="line">初始群集状态（“<span class="keyword">new</span><span class="type"></span>”或“existing”）。 在初始静态或DNS引导过程中为所有成员设置为<span class="keyword">new</span><span class="type"></span>。 如果此选项设置为existing，etcd将尝试加入现有的集群。 如果设置了错误的值，etcd将尝试启动，但安全失败。默认是<span class="keyword">new</span><span class="type"></span></span><br></pre></td></tr></table></figure><ul><li>–initial-cluster-token       </li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：TCD_INITIAL_CLUSTER_TOKEN </span><br><span class="line">在引导期间，etcd集群的初始集群令牌。默认是etcd-<span class="keyword">cluster</span></span><br></pre></td></tr></table></figure><ul><li>–advertise-client-urls      </li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_ADVERTISE_CLIENT_URLS </span><br><span class="line">此成员的客户端<span class="built_in">URL</span>列表，以通告给群集的其余部分。 这些<span class="built_in">URL</span>可以包含域名，默认是<span class="keyword">http</span>://localhost:<span class="number">2379</span></span><br></pre></td></tr></table></figure><ul><li>–discovery  </li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_DISCOVERY </span><br><span class="line">用于引导群集的发现<span class="built_in">URL</span>。默认是<span class="literal">none</span></span><br></pre></td></tr></table></figure><ul><li>–discovery-srv  </li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_DISCOVERY_SRV</span><br><span class="line">用于引导群集的DNS srv域。默认是<span class="keyword">none</span></span><br></pre></td></tr></table></figure><ul><li>–discovery-fallback </li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_DISCOVERY_FALLBACK</span><br><span class="line">发现服务失败时的预期行为（“<span class="keyword">exit</span>”或“proxy”）。 <span class="string">"proxy"</span>仅支持v2 API。默认是proxy</span><br></pre></td></tr></table></figure><ul><li>–discovery-proxy </li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_DISCOVERY_PROXY </span><br><span class="line">用于流量发现服务的HTTP代理。默认是<span class="keyword">none</span></span><br></pre></td></tr></table></figure><ul><li>–strict-reconfig-check</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_STRICT_RECONFIG_CHECK</span><br><span class="line">拒绝会导致法定人数丢失的重新配置请求。默认是<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>–enable-v2   </li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为：ETCD_ENABLE_V2 </span><br><span class="line">接受etcd V2客户端的请求，默认是<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>–auto-compaction-retention</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">环境变量为： ETCD_AUTO_COMPACTION_RETENTION </span><br><span class="line">自动压缩保留mvcc键值存储在小时内。 <span class="number">0</span>意味着禁用自动压缩。默认是<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="etcd使用"><a href="#etcd使用" class="headerlink" title="etcd使用"></a>etcd使用</h3><p>用户主要通过putting 或getting key来与etcd进行交互。 本节介绍如何通过使用etcdctl（一个用于与etcd服务器交互的命令行工具）来完成此操作。 这里描述的概念应该适用于gRPC API或客户端库API。</p><p>默认情况下，etcdctl会与v2 API与etcd服务器通信以实现向后兼容。 对于etcdctl使用v3 API与etcd对话，API版本必须通过ETCDCTL_API环境变量设置为版本3。</p><ul><li>查看版本</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-<span class="literal">master</span>:~<span class="comment"># etcdctl version</span></span><br><span class="line">etcdctl <span class="keyword">version</span>: <span class="number">3.2</span>.<span class="number">11</span></span><br><span class="line">API <span class="keyword">version</span>: <span class="number">3.2</span></span><br><span class="line">root@k8s-<span class="literal">master</span>:~<span class="comment"># etcd -version</span></span><br><span class="line">etcd <span class="keyword">Version</span>: <span class="number">3.2</span>.<span class="number">11</span></span><br><span class="line">Git SHA: <span class="number">1</span>e1dbb2</span><br><span class="line">Go <span class="keyword">Version</span>: go1.<span class="number">8.5</span></span><br><span class="line">Go OS/Arch: linux/amd64</span><br></pre></td></tr></table></figure><ul><li>写入key<br>应用程序通过写入key、value存储到etcd集群中。 每个存储的key通过Raft协议复制到所有etcd集群成员，以实现一致性和可靠性。</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="symbol">@k8s</span>-master:~<span class="meta"># etcdctl  --endpoints=$ENDPOINTS put foo bar</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li>读取key</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~# etcdctl  <span class="attribute">--endpoints</span>=<span class="variable">$ENDPOINTS</span> <span class="builtin-name">get</span>  foo</span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root<span class="title">@k8s-master</span>:~# etcdctl  --endpoints=$ENDPOINTS get  foo  --hex #格式化为<span class="number">16</span>进制</span><br><span class="line">\<span class="keyword">x</span><span class="number">66</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>f</span><br><span class="line">\<span class="keyword">x</span><span class="number">62</span>\<span class="keyword">x</span><span class="number">61</span>\<span class="keyword">x</span><span class="number">72</span></span><br></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~# etcdctl  --endpoints=$ENDPOINTS get  foo  --<span class="built_in">print</span>-<span class="keyword">value</span>-<span class="keyword">only</span> #只显示<span class="keyword">value</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure><ul><li>删除key</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="symbol">@k8s</span>-master:~<span class="meta"># etcdctl  --endpoints=$ENDPOINTS del  foo</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~# etcdctl  --endpoints=$ENDPOINTS del --<span class="built_in">prev</span>-kv  foo #删除并显示<span class="built_in">key</span>、<span class="built_in">value</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><ul><li>实时监控key的变化</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~# etcdctl  --endpoints=<span class="symbol">$</span>ENDPOINTS watch  foo #在另外窗口执行了<span class="keyword">put</span>操作</span><br><span class="line"><span class="keyword">PUT</span></span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>以上是一一些简单的使用，详细请参考官方文档：</p><p><a href="https://coreos.com/etcd/docs/latest/dev-guide/interacting_v3.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dev-guide/interacting_v3.html</a></p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/25/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B9%8Betcd/#disqus_thread</comments>
    </item>
    
    <item>
      <title>docker容器网络三之vxlan</title>
      <link>http://blog.loveops.com/2017/12/21/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%89%E4%B9%8Bvxlan/</link>
      <guid>http://blog.loveops.com/2017/12/21/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%89%E4%B9%8Bvxlan/</guid>
      <pubDate>Thu, 21 Dec 2017 05:26:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;在上篇文章中，我们已经看到了Docker如何为overlay网络创建一个专用的namespace，并将这些容器连接到这个namespace
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在上篇文章中，我们已经看到了Docker如何为overlay网络创建一个专用的namespace，并将这些容器连接到这个namespace。 我们也看到，Docker主机之间的overlay通信使用VXLAN。 在这篇文章中，我们将详细介绍VXLAN以及Docker如何使用它。</p><h4 id="什么是vxlan"><a href="#什么是vxlan" class="headerlink" title="什么是vxlan"></a>什么是vxlan</h4><p>维基百科：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟局域网扩展（<span class="keyword">Virtual</span> Extensible LAN, VXLAN）是一种网络虚拟化技术，它试图改善大云计算部署相关的可扩展性问题.</span><br></pre></td></tr></table></figure></p><p>XLAN是一种隧道技术，它将L2帧封装在UDP包内,通常在端口4789上。它最初是由VMware，Arista和Cisco开发的。 VXLAN的主要目标是简化在L2层需要多租户的云部署。 它提供：</p><ul><li>在L3上隧道化L2以避免集群中所有主机之间的L2连接的必要性</li><li>超过4096个隔离网络（VLAN ID限制为4096）<br>在Linux上，Openvswitch支持VXLAN，并且从3.7版本开始，内核就具有原生支持。 另外，VXLAN自内核3.16起使用网络命名空间。<br>下面是VXLAN包的示意图：<br><img src="/images/vxlan1.png" alt=""></li></ul><p>“outer”ip packet用户主机之间的通信，原始的L2 frame 和 VXLAN header元数据（特别是VXLAN ID）封装在一个udp packet中.</p><p>我们可以用tcpdump验证主机之间的流量是否使用了vxlan， 我们从docker1上的容器ping C0，并捕获docker0上的流量：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ docker <span class="builtin-name">run</span> -it --rm --net demonet debian<span class="built_in"> ping </span>192.168.0.100</span><br><span class="line">PING 192.168.0.100 (192.168.0.100): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.0.100: <span class="attribute">icmp_seq</span>=0 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.680 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.0.100: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.503 ms</span><br><span class="line"></span><br><span class="line">docker0:~$ sudo tcpdump -pni eth0 <span class="string">"port 4789"</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v <span class="keyword">or</span> -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">12:55:53.652322<span class="built_in"> IP </span>10.0.0.11.64667 &gt; 10.0.0.10.4789: VXLAN, flags [I] (0x08), vni 256</span><br><span class="line">IP 192.168.0.2 &gt; 192.168.0.100: ICMP echo request, id 1, seq 0, length 64</span><br><span class="line"></span><br><span class="line">12:55:53.652409<span class="built_in"> IP </span>10.0.0.10.47697 &gt; 10.0.0.11.4789: VXLAN, flags [I] (0x08), vni 256</span><br><span class="line">IP 192.168.0.100 &gt; 192.168.0.2: ICMP echo reply, id 1, seq 0, length 64</span><br></pre></td></tr></table></figure></p><p>每个数据包在tcpdump中生成两行输出，因为由于VXLAN帧分析（为了便于阅读，有些字段已被删除）：<br>“outer”frame ip是10.0.0.11 和 10.0.0.10 （docker hosts）<br>“inner”frame ip是192.168.0.100 and 192.168.0.2（容器），还有icmp的正常包，我们也能看到容器的mac地址。<br><img src="/images/vxlan2.png" alt=""></p><h4 id="解决容器名称和位置"><a href="#解决容器名称和位置" class="headerlink" title="解决容器名称和位置"></a>解决容器名称和位置</h4><p>我们已经看到，我们可以使用VXLAN从docker1上的容器ping docker0上的容器，但我们还不知道每个主机上的容器如何将IP地址映射到MAC地址以及L2帧如何转发到相应的主机。<br>我们在docker1上创建一个容器并查看它的ARP表：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ docker <span class="builtin-name">run</span> -it --rm --net demonet debian bash</span><br><span class="line">root@6234b23677b9:/#<span class="built_in"> ip neighbor </span>show</span><br></pre></td></tr></table></figure></p><p>容器内没有ARP信息。 如果我们ping C0，容器将产生ARP流量。 我们先来看看在docker0的overlay命名空间中如何看到这个流量：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker0:</span>~<span class="variable">$ </span>sudo nsenter --net=<span class="variable">$overns</span> tcpdump -pni any <span class="string">"arp"</span></span><br></pre></td></tr></table></figure></p><p>回到我们的容器，我们将尝试ping C0，这将产生一个ARP数据包：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@6234b23677b9:/#<span class="built_in"> ping </span>192.168.0.100</span><br></pre></td></tr></table></figure></p><p>docker0上的tcpdump中没有任何内容，所以ARP流量不会在VXLAN隧道中发送（您可能会看到ARP请求，但是没有主机192.168.0.100的）。 让我们在docker1的overlay命名空间中创建一个容器，用tcpdump验证我们是否正在收到ARP查询。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--rm --net demonet debian bash</span></span><br></pre></td></tr></table></figure></p><p>让我们在另一个窗口中运行tcpdump。 我们列出Docker网络名称空间，以标识与叠加层关联的名称空间。 这个命名空间可能会改变，因为当没有容器连接到网络时，覆盖命名空间被删除。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker1:</span>~$ sudo ls <span class="number">-1</span> <span class="meta-keyword">/var/</span>run<span class="meta-keyword">/docker/</span>netns</span><br><span class="line"><span class="number">102022</span>d57fab</span><br><span class="line">x<span class="number">-13</span>fb802253</span><br><span class="line"><span class="symbol">docker1:</span>~$ overns=<span class="meta-keyword">/var/</span>run<span class="meta-keyword">/docker/</span>netns/x<span class="number">-13</span>fb802253</span><br><span class="line"><span class="symbol">docker1:</span>~$ sudo nsenter --net=$overns tcpdump -peni any <span class="string">"arp"</span></span><br></pre></td></tr></table></figure></p><p>当我们用容器从窗口ping时，这里是我们在tcpdump中看到的：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">19<span class="selector-pseudo">:16</span><span class="selector-pseudo">:40.658369</span> <span class="selector-tag">Out</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span> <span class="selector-tag">ethertype</span> <span class="selector-tag">ARP</span> (0<span class="selector-tag">x0806</span>), <span class="selector-tag">length</span> 44: <span class="selector-tag">Request</span> <span class="selector-tag">who-has</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.100</span> <span class="selector-tag">tell</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.2</span>, <span class="selector-tag">length</span> 28</span><br><span class="line">19<span class="selector-pseudo">:16</span><span class="selector-pseudo">:40.658352</span>   <span class="selector-tag">B</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span> <span class="selector-tag">ethertype</span> <span class="selector-tag">ARP</span> (0<span class="selector-tag">x0806</span>), <span class="selector-tag">length</span> 44: <span class="selector-tag">Request</span> <span class="selector-tag">who-has</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.100</span> <span class="selector-tag">tell</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.2</span>, <span class="selector-tag">length</span> 28</span><br><span class="line">19<span class="selector-pseudo">:16</span><span class="selector-pseudo">:40.658371</span>  <span class="selector-tag">In</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:64</span> <span class="selector-tag">ethertype</span> <span class="selector-tag">ARP</span> (0<span class="selector-tag">x0806</span>), <span class="selector-tag">length</span> 44: <span class="selector-tag">Reply</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.100</span> <span class="selector-tag">is-at</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:64</span>, <span class="selector-tag">length</span> 28</span><br><span class="line">19<span class="selector-pseudo">:16</span><span class="selector-pseudo">:40.658377</span> <span class="selector-tag">Out</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:64</span> <span class="selector-tag">ethertype</span> <span class="selector-tag">ARP</span> (0<span class="selector-tag">x0806</span>), <span class="selector-tag">length</span> 44: <span class="selector-tag">Reply</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.100</span> <span class="selector-tag">is-at</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:64</span>, <span class="selector-tag">length</span> 28</span><br></pre></td></tr></table></figure></p><p>我们可以看到ARP查询和应答，这意味着overlay命名空间有信息，并且它充当ARP代理。 我们可以轻松验证这一点：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ sudo nsenter <span class="attribute">--net</span>=<span class="variable">$overns</span><span class="built_in"> ip </span>neigh show</span><br><span class="line">192.168.0.100 dev vxlan0 lladdr 02:42:c0:a8:00:64 PERMANENT</span><br></pre></td></tr></table></figure></p><p>该条目被标记为PERMANENT，这意味着它是静态的并且是“手动”添加的，而不是ARP发现的结果。 如果我们在docker0上创建第二个容器会发生什么？<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker <span class="builtin-name">run</span> -d --ip 192.168.0.200 --net demonet --name C1 debian sleep 3600</span><br><span class="line"></span><br><span class="line">docker1:~$ sudo nsenter <span class="attribute">--net</span>=<span class="variable">$overns</span><span class="built_in"> ip </span>neigh show</span><br><span class="line">192.168.0.200 dev vxlan0 lladdr 02:42:c0:a8:00:c8 PERMANENT</span><br><span class="line">192.168.0.100 dev vxlan0 lladdr 02:42:c0:a8:00:64 PERMANENT</span><br></pre></td></tr></table></figure></p><p>该条目已被自动添加，即使没有流量发送到这个新的容器呢。 这意味着Docker会自动填充覆盖命名空间中的ARP条目，并且vxlan接口将充当代理来回答ARP查询。</p><p>如果我们看一下vxlan接口的配置，我们可以看到它具有代理标志集，这解释了这种行为（我们稍后会看到其他选项）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ sudo nsenter <span class="attribute">--net</span>=<span class="variable">$overns</span><span class="built_in"> ip </span>-d link show vxlan0</span><br><span class="line">xx: vxlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 5a:71:8f:a4:b8:1b brd ff:ff:ff:ff:ff:ff promiscuity 1</span><br><span class="line">    vxlan id 256 srcport 10240 65535 dstport 4789<span class="built_in"> proxy </span>l2miss l3miss ageing 300</span><br><span class="line">    bridge_slav</span><br></pre></td></tr></table></figure><p>MAC地址的位置（主机是02:42:c0:a8:00:64）呢？ 我们可以看看overlay命名空间中的桥接转发数据库：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ sudo nsenter <span class="attribute">--net</span>=<span class="variable">$overns</span><span class="built_in"> bridge </span>fdb show</span><br><span class="line">5a:71:8f:a4:b8:1b dev vxlan0<span class="built_in"> vlan </span>0 master br0 permanent</span><br><span class="line">9a:ad:35:64:39:39 dev veth2<span class="built_in"> vlan </span>0 master br0 permanent</span><br><span class="line">02:42:c0:a8:00:c8 dev vxlan0 dst 10.0.0.10 self permanent</span><br><span class="line">02:42:c0:a8:00:64 dev vxlan0 dst 10.0.0.10 self permanent</span><br><span class="line">33:33:00:00:00:01 dev veth2 self permanent</span><br><span class="line">01:00:5e:00:00:01 dev veth2 self permanent</span><br></pre></td></tr></table></figure></p><p>我们可以看到docker0上的两个容器的MAC地址在数据库中有一个永久标志。 这个信息也是由Docker动态填充的。<br><img src="/images/vxlan3.png" alt=""></p><h4 id="MAC-FDB信息的分配"><a href="#MAC-FDB信息的分配" class="headerlink" title="MAC/FDB信息的分配"></a>MAC/FDB信息的分配</h4><p>我们刚刚发现Docker会自动填充MAC和FDB信息。 这是怎么做的？<br>我们可以先看看consul的内容。 那里存储了什么？<br><img src="/images/vxlan4.png" alt=""><br>现在我们刚开始的时候空的网络包含了信息，我们可以识别overlay的ID：<br>13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a.<br>Consul用户界面太长时不显示键值，但我们可以用curl来查看内容（Docker将信息存储为基于64位编码的JSON，Consul用JSON来回答查询）：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net=<span class="string">$(</span>docker network inspect demonet -f &#123;&#123;.<span class="type">Id</span>&#125;&#125;)</span><br><span class="line">curl -s http://consul:<span class="number">8500</span>/v1/kv/docker/network/v1<span class="number">.0</span>/network/<span class="string">$&#123;</span>net&#125;/ | jq  -r <span class="comment">".[0].Value"</span>  |  base64 -d | jq .</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">"addrSpace"</span>: <span class="comment">"GlobalDefault"</span>,</span><br><span class="line">  <span class="comment">"attachable"</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">"created"</span>: <span class="comment">"2017-04-23T16:33:02.442759329Z"</span>,</span><br><span class="line">  <span class="comment">"enableIPv6"</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">"generic"</span>: &#123;</span><br><span class="line">    <span class="comment">"com.docker.network.enable_ipv6"</span>: <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">"com.docker.network.generic"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">"id"</span>: <span class="comment">"13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a"</span>,</span><br><span class="line">  <span class="comment">"inDelete"</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">"ingress"</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">"internal"</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">"ipamOptions"</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">"ipamType"</span>: <span class="comment">"default"</span>,</span><br><span class="line">  <span class="comment">"ipamV4Config"</span>: <span class="comment">"[&#123;\"</span><span class="type">PreferredPool</span>\<span class="comment">":\"</span><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span>\<span class="comment">",\"</span><span class="type">SubPool</span>\<span class="comment">":\"</span>\<span class="comment">",\"</span><span class="type">Gateway</span>\<span class="comment">":\"</span>\<span class="comment">",\"</span><span class="type">AuxAddresses</span>\<span class="comment">":null&#125;]"</span>,</span><br><span class="line">  <span class="comment">"ipamV4Info"</span>: <span class="comment">"[&#123;\"</span><span class="type">IPAMData</span>\<span class="comment">":\"</span>&#123;\\\<span class="comment">"AddressSpace\\\"</span>:\\\<span class="comment">"GlobalDefault\\\"</span>,\\\<span class="comment">"Gateway\\\"</span>:\\\<span class="comment">"192.168.0.1/24\\\"</span>,\\\<span class="comment">"Pool\\\"</span>:\\\<span class="comment">"192.168.0.0/24\\\"</span>&#125;\<span class="comment">",\"</span><span class="type">PoolID</span>\<span class="comment">":\"</span><span class="type">GlobalDefault</span>/<span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span>\<span class="comment">"&#125;]"</span>,</span><br><span class="line">  <span class="comment">"labels"</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">"name"</span>: <span class="comment">"demonet"</span>,</span><br><span class="line">  <span class="comment">"networkType"</span>: <span class="comment">"overlay"</span>,</span><br><span class="line">  <span class="comment">"persist"</span>: <span class="keyword">true</span>,</span><br><span class="line">  <span class="comment">"postIPv6"</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">"scope"</span>: <span class="comment">"global"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以在我们的网络上找到所有的元数据：</p><ul><li>name：demonet</li><li>id：13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a</li><li>subnet：192.168.0.0/24</li></ul><p>我们也可以检索关于端点的信息，但curl查询很难读取，所以我们将使用这个小的python脚本（<a href="https://github.com/lbernail/dockeroverlays）" target="_blank" rel="noopener">https://github.com/lbernail/dockeroverlays）</a> 来检索这些信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> consul</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># First we connect to consul</span></span><br><span class="line">c=consul.Consul(host=<span class="string">"consul"</span>,port=<span class="number">8500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We retrieve all endpoint keys from Consul</span></span><br><span class="line">(idx,endpoints)=c.kv.get(<span class="string">"docker/network/v1.0/endpoint/"</span>,recurse=<span class="keyword">True</span>)</span><br><span class="line">epdata=[ ep[<span class="string">'Value'</span>] <span class="keyword">for</span> ep <span class="keyword">in</span> endpoints <span class="keyword">if</span> ep[<span class="string">'Value'</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We print some interesting data on these endpoints</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> epdata:</span><br><span class="line">    jsondata=json.loads(data.decode(<span class="string">"utf-8"</span>))</span><br><span class="line">    print(<span class="string">"Endpoint Name: %s"</span> % jsondata[<span class="string">"name"</span>])</span><br><span class="line">    print(<span class="string">"IP address: %s"</span> % jsondata[<span class="string">"ep_iface"</span>][<span class="string">"addr"</span>])</span><br><span class="line">    print(<span class="string">"MAC address: %s"</span> % jsondata[<span class="string">"ep_iface"</span>][<span class="string">"mac"</span>])</span><br><span class="line">    print(<span class="string">"Locator: %s\n"</span> % jsondata[<span class="string">"locator"</span>])</span><br></pre></td></tr></table></figure></p><p>脚本显示容器端点上的主要信息：</p><ul><li>name</li><li>IP address</li><li>MAC address</li><li>Locator：容器所在的主机</li></ul><p>以下是输出结果：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ python/dump_endpoints.py</span><br><span class="line">Endpoint Name: adoring_einstein</span><br><span class="line">IP address: 192.168.0.2/24</span><br><span class="line">MAC address: 02:42:c0:a8:00:02</span><br><span class="line">Locator: 10.0.0.11</span><br><span class="line"></span><br><span class="line">Endpoint Name: C1</span><br><span class="line">IP address: 192.168.0.200/24</span><br><span class="line">MAC address: 02:42:c0:a8:00:c8</span><br><span class="line">Locator: 10.0.0.10</span><br></pre></td></tr></table></figure></p><p>Consul被用作所有静态信息的参考存储。 但是，创建容器时动态通知所有主机是不够的。 事实证明，Docker使用Serf和Gossip协议来实现这一点。 我们可以通过订阅docker0上的serf事件来轻松验证这一点，并在docker1上创建一个容器：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ serf agent -bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">17946</span> -join <span class="number">10.0</span><span class="number">.0</span><span class="number">.11</span>:<span class="number">7946</span> -node demo -log-level=debug -event-handler=./serf.sh</span><br><span class="line">#########################################</span><br><span class="line">New event: member-join</span><br><span class="line">demo<span class="number">10.0</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line">docker0<span class="number">10.0</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line">docker1<span class="number">10.0</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line">#########################################</span><br></pre></td></tr></table></figure></p><p>我删除了大部分输出以关注相关信息：我们可以看到所有参与Gossip的节点。<br>Serf选项解释如下：</p><ul><li>bind：绑定一个不同于7946的端口（已经被Docker使用）</li><li>join：to join the serf cluster</li><li>node：为节点指定一个备用名（docker0已经被占用）</li><li>event-handler：一个简单的脚本来显示serf事件</li><li>log-level = debug：需要查看事件处理程序脚本的输出</li></ul><p>serf.sh脚本具有以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"New event: <span class="variable">$&#123;SERF_EVENT&#125;</span>"</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"<span class="variable">$&#123;line&#125;</span>\n"</span></span><br></pre></td></tr></table></figure></p><p>现在让我们在docker 1上创建一个容器并查看docker0上的输出：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ docker <span class="keyword">run</span> -it --<span class="keyword">rm</span> --<span class="keyword">net</span> demonet debian <span class="keyword">sleep</span> 10</span><br></pre></td></tr></table></figure></p><p>在docker0 我们可以看到：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">New</span> <span class="selector-tag">event</span>: <span class="selector-tag">user</span></span><br><span class="line"><span class="selector-tag">join</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.2</span> 255<span class="selector-class">.255</span><span class="selector-class">.255</span><span class="selector-class">.0</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span></span><br></pre></td></tr></table></figure></p><p>然后在10秒钟之后当容器在docker1上退出：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">New</span> <span class="selector-tag">event</span>: <span class="selector-tag">user</span></span><br><span class="line"><span class="selector-tag">leave</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.2</span> 255<span class="selector-class">.255</span><span class="selector-class">.255</span><span class="selector-class">.0</span> 02<span class="selector-pseudo">:42</span><span class="selector-pseudo">:c0</span><span class="selector-pseudo">:a8</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span></span><br></pre></td></tr></table></figure></p><p>Docker守护程序订阅这些事件来创建和删除ARP和FDB表中的条目。</p><p><img src="/images/vxlan5.png" alt=""><br>在Swarm模式下，Docker不依赖Serf来同步节点之间的信息，而是依靠自己的Gossip协议实现。 它实现了完全一样的事情。</p><h4 id="备用解决选项"><a href="#备用解决选项" class="headerlink" title="备用解决选项"></a>备用解决选项</h4><p>Docker守护程序根据通过Serf通过Gossip协议接收到的信息自动填充ARP和FDB表，并依靠VLXAN接口进行ARP代理。 但是，VXLAN还为我们提供了其他发现选项。</p><h5 id="点对点方式"><a href="#点对点方式" class="headerlink" title="点对点方式"></a>点对点方式</h5><p>当VXLAN配置了“remote”选项时，它将所有未知流量发送到这个IP，这个设置非常简单，但是仅限于两台主机之间的隧道。<br><img src="/images/vxlan6.png" alt=""></p><h5 id="多播方式"><a href="#多播方式" class="headerlink" title="多播方式"></a>多播方式</h5><p>当VXLAN配置了“group”选项时，它将所有未知流量发送到这个组播组，这个设置非常高效，但是需要所有主机之间的组播连接，这在使用公共云时并不总是可行的。<br><img src="/images/vxlan7.png" alt=""></p><p>有关Linux上VXLAN配置的更多详细信息，我推荐这个非常完整的文章：</p><p><a href="https://vincent.bernat.im/en/blog/2017-vxlan-linux" target="_blank" rel="noopener">https://vincent.bernat.im/en/blog/2017-vxlan-linux</a></p><p>原文：</p><p><a href="http://techblog.d2-si.eu/2017/05/09/deep-dive-into-docker-overlay-networks-part-2.html" target="_blank" rel="noopener">http://techblog.d2-si.eu/2017/05/09/deep-dive-into-docker-overlay-networks-part-2.html</a></p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/21/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%89%E4%B9%8Bvxlan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>docker容器网络二之overlay</title>
      <link>http://blog.loveops.com/2017/12/20/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%BA%8C%E4%B9%8Boverlay/</link>
      <guid>http://blog.loveops.com/2017/12/20/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%BA%8C%E4%B9%8Boverlay/</guid>
      <pubDate>Wed, 20 Dec 2017 08:32:21 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;在上一篇docker网络一中，介绍了docker单主机的几种网络模式，这篇文章将介绍跨主机网络overlay，这个是docker原生的跨
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在上一篇docker网络一中，介绍了docker单主机的几种网络模式，这篇文章将介绍跨主机网络overlay，这个是docker原生的跨主机网络模型。docker的overlay网络依以下技术：namespace、VXLAN、Netlink和分布式键值存储。这篇文章将介绍这些组件怎么联动，从而组成docker的overlay网络。</p><h4 id="Docker-Overlay-Networks"><a href="#Docker-Overlay-Networks" class="headerlink" title="Docker Overlay Networks"></a>Docker Overlay Networks</h4><p>首先，我们将在Docker主机之间构建一个overlay网络。 在我们的例子中，我们将使用三个主机来执行此操作：两个正在运行的Docker和一个正在运行的Consul。 Docker将使用Consul来存储需要由所有Docker引擎共享的overlay网络元数据：容器IP，MAC地址和位置。 在Docker 1.12之前，Docker需要一个外部键值存储（Etcd或Consul）来创建overlay和Docker Swarms（现在通常被称为“classicSwarm”）。 从Docker 1.12开始，Docker现在可以依靠一个内置的Key-Value存储来创建Swarms和overlay（“Swarm mode”或“new swarm”）。 我们选择使用Consul是因为它允许我们查看Docker存储的密钥并更好地理解Key-Value存储的角色。 我们在单个节点上运行Consul，但是在真实的环境中，我们需要一个至少有三个节点的集群来提供弹性。<br>在我们的示例中，服务器将具有以下IP地址：</p><ul><li>consul: 10.0.0.5</li><li>docker0: 10.0.0.10</li><li>docker1: 10.0.0.0.11<br><img src="/images/overlay1.png" alt=""></li></ul><h4 id="启动Consul和Docker"><a href="#启动Consul和Docker" class="headerlink" title="启动Consul和Docker"></a>启动Consul和Docker</h4><p>我们需要做的第一件事是启动一个Consul服务器。 要做到这一点，我们只需从consul官网下载Consul。 然后我们可以用下面的命令启动一个非常小的Consul服务：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul agent -server -dev -ui -client <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p><p>我们使用以下参数：</p><ul><li>server：以服务器模式启动代理服务器</li><li>dev：创建一个没有任何持久性的独立Consul服务器</li><li>ui：启动一个小型web界面，使我们可以轻松查看Docker存储的密钥及其值</li><li>client 0.0.0.0：绑定客户端访问的所有网络接口（默认为127.0.0.1）</li></ul><p>要将Docker引擎配置为使用Consul作为Key-Value存储，我们使用cluster-store选项启动守护进程：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl cat docker.service</span><br><span class="line"><span class="comment"># /lib/systemd/system/docker.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target docker.socket firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="comment"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class="line"><span class="comment"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class="line"><span class="comment"># for containers run by docker</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --cluster-store=consul://10.0.0.5:8500 --cluster-advertise=eth0:2376</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line"><span class="comment"># Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="comment"># in the kernel. We recommend using cgroups to do container-local accounting.</span></span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="comment"># Uncomment TasksMax if your systemd version supports it.</span></span><br><span class="line"><span class="comment"># Only systemd 226 and above support this version.</span></span><br><span class="line">TasksMax=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"><span class="comment"># set delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line">Delegate=yes</span><br><span class="line"><span class="comment"># kill only the docker process, not all processes in the cgroup</span></span><br><span class="line">KillMode=process</span><br><span class="line"><span class="comment"># restart the docker process if it exits prematurely</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><p>cluster-advertise选项指定在集群中为docker主机通告哪个IP（此选项不是可选的）。 这个命令假定consul在我们的例子中解析为10.0.0.5。</p><p>如果我们看一下Consul UI，我们可以看到Docker创建了一些keys，但是网络keys: <a href="http://consul:8500/v1/kv/docker/network/v1.0/network/" target="_blank" rel="noopener">http://consul:8500/v1/kv/docker/network/v1.0/network/</a> 仍然是空的。<br><img src="/images/overlay2.png" alt=""></p><h3 id="创建一个overlay"><a href="#创建一个overlay" class="headerlink" title="创建一个overlay"></a>创建一个overlay</h3><p>现在我们可以在两个主机之间创建一个overlay网络。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker<span class="built_in"> network </span>create --driver overlay --subnet 192.168.0.0/24 demonet</span><br><span class="line">13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a</span><br></pre></td></tr></table></figure></p><p>我们使用overlay驱动程序，并选择192.168.0.0/24作为overlay的子网（该参数是可选的，但我们希望地址与主机上的地址非常不同，以简化分析）。<br>接着就可以坚持两个主机网络中都有我们创建的overlay网络<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker<span class="built_in"> network </span>ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">eb096cb816c0       <span class="built_in"> bridge </span>            <span class="built_in"> bridge </span>             local</span><br><span class="line">13fb802253b6        demonet             overlay             global</span><br><span class="line">d538d58b17e7        host                host                local</span><br><span class="line">f2ee470bb968        none                <span class="literal">null</span>                local</span><br><span class="line"></span><br><span class="line">docker1:~$ docker<span class="built_in"> network </span>ls</span><br><span class="line">docker<span class="built_in"> network </span>ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">eb7a05eba815       <span class="built_in"> bridge </span>            <span class="built_in"> bridge </span>             local</span><br><span class="line">13fb802253b6        demonet             overlay             global</span><br><span class="line">4346f6c422b2        host                host                local</span><br><span class="line">5e8ac997ecfa        none                <span class="literal">null</span>                local</span><br></pre></td></tr></table></figure></p><p>这看起来不错：两个Docker节点都知道demonet网络，并且在两台主机上都有相同的id（13fb802253b6）。</p><p>现在让我们通过在docker0上创建一个容器并试图从docker1 ping它来检查我们的覆盖是如何工作的。 在docker0上，我们创建一个C0容器，将它附加到我们的overlay网络，明确地给它一个IP地址（192.168.0.100），并让它sleep。 在docker1上，我们创建了一个连接到overlay的容器，并运行一个以C0为目标的ping命令。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker <span class="builtin-name">run</span> -d --ip 192.168.0.100 --net demonet --name C0 debian sleep 3600</span><br><span class="line"></span><br><span class="line">docker1:~$ docker <span class="builtin-name">run</span> -it --rm --net demonet debian bash</span><br><span class="line">root@e37bf5e35f83:/#<span class="built_in"> ping </span>192.168.0.100</span><br><span class="line">PING 192.168.0.100 (192.168.0.100): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.0.100: <span class="attribute">icmp_seq</span>=0 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.618 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.0.100: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.483 ms</span><br></pre></td></tr></table></figure></p><p>我们可以看到两个容器之间的连接是可以的。 如果我们试图从docker1 ping C0，它不起作用，因为docker1不知道关于192.168.0.0/24的任何东西，这个192.168.0.0/24被隔离在overlay中。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$<span class="built_in"> ping </span>192.168.0.100</span><br><span class="line">PING 192.168.0.100 (192.168.0.100) 56(84) bytes of data.</span><br><span class="line">^C--- 192.168.0.100<span class="built_in"> ping </span>statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 3024ms</span><br></pre></td></tr></table></figure></p><p>目前我们的拓扑结构是这样的：<br><img src="/images/overlay3.png" alt=""></p><p>更深层次的研究</p><p>现在我们已经构建了一个overlay网络，让我们试着看看它是如何工作的。</p><h5 id="容器的网络配置"><a href="#容器的网络配置" class="headerlink" title="容器的网络配置"></a>容器的网络配置</h5><p>docker0上C0的网络配置是什么？ 我们可以进入容器找出：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker exec C0<span class="built_in"> ip </span>addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN<span class="built_in"> group </span>default</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP<span class="built_in"> group </span>default</span><br><span class="line">    link/ether 02:42:c0:a8:00:64 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.100/24 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">9: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP<span class="built_in"> group </span>default</span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.2/16 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></p><p>我们有两个接口（和环回）在容器中：</p><ul><li>eth0：使用192.168.0.0/24范围内的IP进行配置。 这个接口是我们覆overlay的。</li><li>eth1：配置为172.18.0.2/16范围内的IP，我们没有并没有配置</li></ul><p>路由配置:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker exec C0<span class="built_in"> ip route </span>show</span><br><span class="line">default via 172.18.0.1 dev eth1</span><br><span class="line">172.18.0.0/16 dev eth1  proto kernel  scope link  src 172.18.0.2</span><br><span class="line">192.168.0.0/24 dev eth0  proto kernel  scope link  src 192.168.0.100</span><br></pre></td></tr></table></figure></p><p>路由配置表明默认路由是通过eth1，这意味着这个接口可以用来访问overlay之外的资源。 我们可以通过ping外部IP地址来轻松验证。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it C0<span class="built_in"> ping </span>8.8.8.8</span><br><span class="line">PING 8.8.8.8 (8.8.8.8): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 8.8.8.8: <span class="attribute">icmp_seq</span>=0 <span class="attribute">ttl</span>=51 <span class="attribute">time</span>=0.957 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 8.8.8.8: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=51 <span class="attribute">time</span>=0.975 ms</span><br></pre></td></tr></table></figure><p>请注意，可以使用–internal参数创建一个overlay，使容器无法访问外部网络。</p><p>让我们看看我们是否可以在这些接口上获得更多的信息：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker exec C0<span class="built_in"> ip </span>-details link show eth0</span><br><span class="line">6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 02:42:c0:a8:00:64 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    veth</span><br><span class="line"></span><br><span class="line">docker0:~$ docker exec C0<span class="built_in"> ip </span>-details link show eth1</span><br><span class="line">9: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    veth</span><br></pre></td></tr></table></figure></p><p>两个接口的类型都是veth。 veth接口总是与虚拟线路连接。 这两个对等的veth可以在不同的网络命名空间中，这允许流量从一个命名空间移动到另一个命名空间。 这两个veth用于获取容器网络命名空间的外部。<br>如下图所示：<br><img src="/images/overlay4.png" alt=""><br>我们现在需要确定与每个veth对接的接口。</p><h4 id="容器是链向了哪里"><a href="#容器是链向了哪里" class="headerlink" title="容器是链向了哪里"></a>容器是链向了哪里</h4><p>我们可以使用ethtool命令来确定veth的另一端。 但是这个命令在我们的容器中不可用。 我们可以使用“nsenter”在我们的容器中执行这个命令，它允许我们输入一个或多个与进程相关的命名空间，或者使用“ip netns exec”，依靠iproute在给定的网络命名空间中执行一个命令。 Docker不在/var/run/netns目录中创建符号链接，这是ip netns正在寻找网络命名空间的地方。 这就是为什么我们会依赖nsenter来创建由Docker创建的名称空间的原因。<br>要列出由Docker创建的网络名称空间，我们可以简单地运行：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ sudo ls -<span class="number">1</span> /var/<span class="keyword">run</span><span class="bash">/docker/netns</span></span><br><span class="line"><span class="bash">e4b8ecb7ae7c</span></span><br><span class="line"><span class="bash">1-13fb802253</span></span><br></pre></td></tr></table></figure></p><p>要使用这些信息，我们需要识别容器的网络名称空间。 我们可以通过检查他们来实现<br>这一点，并从SandboxKey中提取我们需要的东西：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker0:</span>~$ docker inspect C0 -<span class="class">f </span>&#123;&#123;.NetworkSettings.SandboxKey&#125;&#125;</span><br><span class="line"> <span class="meta-keyword">/var/</span>run<span class="meta-keyword">/docker/</span>netns/e4b8ecb7ae7c</span><br><span class="line"><span class="symbol">docker0:</span>~$ C0netns=$(docker inspect C0 -<span class="class">f </span>&#123;&#123;.NetworkSettings.SandboxKey&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>我们也可以在容器的网络命名空间内执行主机命令（即使这个容器没有命令）：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ sudo nsenter <span class="attribute">--net</span>=<span class="variable">$C0netns</span><span class="built_in"> ip </span>addr show eth0</span><br><span class="line">6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP<span class="built_in"> group </span>default</span><br><span class="line">    link/ether 02:42:c0:a8:00:64 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.100/24 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></p><p>我们来看看与eth0和eth1的对等体相关的接口索引是什么：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">docker0:</span><span class="string">~$</span> <span class="string">sudo</span> <span class="string">nsenter</span> <span class="bullet">--net=$C0netns</span> <span class="string">ethtool</span> <span class="bullet">-S</span> <span class="string">eth0</span></span><br><span class="line"><span class="string">NIC</span> <span class="attr">statistics:</span></span><br><span class="line"><span class="attr">    peer_ifindex:</span> <span class="number">7</span></span><br><span class="line"><span class="attr">docker0:</span><span class="string">~$</span> <span class="string">sudo</span> <span class="string">nsenter</span> <span class="bullet">--net=$C0netns</span> <span class="string">ethtool</span> <span class="bullet">-S</span> <span class="string">eth1</span></span><br><span class="line"><span class="string">NIC</span> <span class="attr">statistics:</span></span><br><span class="line"><span class="attr">    peer_ifindex:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>我们现在正在寻找索引7和10的接口。我们可以先看看主机本身：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$<span class="built_in"> ip </span>-details link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc pfifo_fast state UP mode<span class="built_in"> DEFAULT group default </span>qlen 1000</span><br><span class="line">    link/ether 06:e2:c0:20:ec:9f brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 02:42:a7:17:99:39 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    bridge</span><br><span class="line">8: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 02:42:be:d6:b0:c5 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    bridge</span><br><span class="line">10: vethbc521fc: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 32:a1:47:1a:7f:1e brd ff:ff:ff:ff:ff:ff promiscuity 1</span><br><span class="line">    veth</span><br><span class="line">    bridge_slave</span><br></pre></td></tr></table></figure></p><p>从这个输出我们可以看到，我们没有接口7的踪迹，但是我们已经找到接口10，即eth1的对等体。 另外，这个接口被插在一个名为“docker_gwbridge”的桥上。 这座桥是什么？ 如果我们列出由docker管理的网络，我们可以看到它出现在列表中：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker<span class="built_in"> network </span>ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">eb096cb816c0       <span class="built_in"> bridge </span>            <span class="built_in"> bridge </span>             local</span><br><span class="line">13fb802253b6        demonet             overlay             global</span><br><span class="line">f6823b311fd2        docker_gwbridge    <span class="built_in"> bridge </span>             local</span><br><span class="line">d538d58b17e7        host                host                local</span><br><span class="line">f2ee470bb968        none                <span class="literal">null</span>                local</span><br></pre></td></tr></table></figure></p><p>进一步查看：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker<span class="number">0</span>:~$ docker inspect docker_gwbridge</span><br><span class="line"><span class="string">"Name"</span>: <span class="string">"docker_gwbridge"</span>,</span><br><span class="line"><span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line"><span class="string">"IPAM"</span>: &#123;</span><br><span class="line">    <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">    <span class="string">"Options"</span>: null,</span><br><span class="line">    <span class="string">"Config"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"Subnet"</span>: <span class="string">"172.18.0.0/16"</span>,</span><br><span class="line">            <span class="string">"Gateway"</span>: <span class="string">"172.18.0.1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"Options"</span>: &#123;</span><br><span class="line">    <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"false"</span>,</span><br><span class="line">    <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</span><br><span class="line">    <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker_gwbridge"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>我删除了输出的一部分，以关注重要的信息：</p><ul><li>该网络使用网桥（与标准的docker0一样）</li><li>它使用子网172.18.0.0/16，与eth1一致</li><li>enable_icc被设置为false，这意味着我们不能使用这个桥进行集装箱间通信</li><li>enable_ip_masquerade设置为true，这意味着来自容器的流量将被NAT到访问外部网络（我们之前在成功调用8.8.8.8时看到的）</li></ul><p>我们可以通过尝试从附加到demonet的docker0的另一个容器的eth1地址（172.18.0.2）ping C0来验证集装箱间通信是否被禁用：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker <span class="builtin-name">run</span> --rm -it --net demonet debian<span class="built_in"> ping </span>172.18.0.2</span><br><span class="line">PING 172.18.0.2 (172.18.0.2): 56 data bytes</span><br><span class="line">^C--- 172.18.0.2<span class="built_in"> ping </span>statistics ---</span><br><span class="line">3 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></figure></p><p>现在更新拓扑：<br><img src="/images/overlay5.png" alt=""></p><h4 id="那么eth0是否就是链接到overlay网络呢？"><a href="#那么eth0是否就是链接到overlay网络呢？" class="headerlink" title="那么eth0是否就是链接到overlay网络呢？"></a>那么eth0是否就是链接到overlay网络呢？</h4><p>与eth0对等的接口不在主机网络名称空间中。 它必须在另一个。 如果我们再看网络命名空间：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ sudo ls -<span class="number">1</span> /var/<span class="keyword">run</span><span class="bash">/docker/netns</span></span><br><span class="line"><span class="bash">e4b8ecb7ae7c</span></span><br><span class="line"><span class="bash">1-13fb802253</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到名为“1-13fb802253”的名称空间。 除了“1-”之外，这个命名空间的名称是我们覆盖网络的网络ID的开始：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker<span class="built_in"> network </span>inspect demonet -f &#123;&#123;.Id&#125;&#125;</span><br><span class="line">13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a</span><br></pre></td></tr></table></figure></p><p>这个命名空间显然与我们的overlay有关。 我们可以看看这个名字空间中的接口：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ <span class="attribute">overns</span>=/var/run/docker/netns/1-13fb802253</span><br><span class="line">docker0:~$ sudo nsenter <span class="attribute">--net</span>=<span class="variable">$overns</span><span class="built_in"> ip </span>-d link show</span><br><span class="line">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 3a:2d:44:c0:0e:aa brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    bridge</span><br><span class="line">5: vxlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 4a:23:72:a3:fc:e3 brd ff:ff:ff:ff:ff:ff promiscuity 1</span><br><span class="line">    vxlan id 256 srcport 10240 65535 dstport 4789<span class="built_in"> proxy </span>l2miss l3miss ageing 300</span><br><span class="line">    bridge_slave</span><br><span class="line">7: veth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP mode<span class="built_in"> DEFAULT group </span>default</span><br><span class="line">    link/ether 3a:2d:44:c0:0e:aa brd ff:ff:ff:ff:ff:ff promiscuity 1</span><br><span class="line">    veth</span><br><span class="line">    bridge_slave</span><br></pre></td></tr></table></figure><p>覆盖网络命名空间包含三个接口（和lo）：</p><ul><li>br0：网桥</li><li>veth2：一个veth接口，它是我们容器中eth0的对等接口，并连接到网桥</li><li>vxlan0：也连接到网桥的“vxlan”类型的接口</li></ul><p>vxlan接口显然是“overlay  magic ”发生的地方，我们将详细看看它，让我们先更新我们的图表：</p><p><img src="/images/overlay6.png" alt=""></p><p>原文：</p><p><a href="http://techblog.d2-si.eu/2017/04/25/deep-dive-into-docker-overlay-networks-part-1.html" target="_blank" rel="noopener">http://techblog.d2-si.eu/2017/04/25/deep-dive-into-docker-overlay-networks-part-1.html</a></p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/20/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%BA%8C%E4%B9%8Boverlay/#disqus_thread</comments>
    </item>
    
    <item>
      <title>docker容器网络一</title>
      <link>http://blog.loveops.com/2017/12/19/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%80/</link>
      <guid>http://blog.loveops.com/2017/12/19/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%80/</guid>
      <pubDate>Tue, 19 Dec 2017 05:50:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;docker网络&quot;&gt;&lt;a href=&quot;#docker网络&quot; class=&quot;headerlink&quot; title=&quot;docker网络&quot;&gt;&lt;/a&gt;docker网络&lt;/h4&gt;&lt;p&gt;docker安装以后默认就有4中网络模式，可以用docker network ls 查看：&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h4><p>docker安装以后默认就有4中网络模式，可以用docker network ls 查看：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker<span class="built_in"> network </span>ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">db6d3a70094b       <span class="built_in"> bridge </span>            <span class="built_in"> bridge </span>             local</span><br><span class="line">7a65f6e2654e        host                host                local</span><br><span class="line">34e659778a9d        none                <span class="literal">null</span>                local</span><br></pre></td></tr></table></figure><p>你会发现查看就有三种。另外一种称为container模式，这个待会儿再说。</p><h4 id="四种网络方式的实现方式"><a href="#四种网络方式的实现方式" class="headerlink" title="四种网络方式的实现方式"></a>四种网络方式的实现方式</h4><ul><li>host</li></ul><p>在这个模式下，docker 不会为容器创建单独的网络 namespace，而是共享主机的 network namespace，也就是说：容器可以直接访问主机上所有的网络信息。既然是共享主机的网络，端口也是共享的，所以容器和主机的端口是不能冲突的。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">主机网络</span><br><span class="line">$<span class="built_in"> ip </span>a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN<span class="built_in"> group default </span>qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP<span class="built_in"> group default </span>qlen 1000</span><br><span class="line">    link/ether 52:54:b9:09:ff:bd brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.1.2/24 brd 172.16.1.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:b9ff:fe09:ffbd/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN<span class="built_in"> group </span>default</span><br><span class="line">    link/ether 02:42:fb:c9:10:09 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:fbff:fec9:1009/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">10: docker_gwbridge: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN<span class="built_in"> group </span>default</span><br><span class="line">    link/ether 02:42:42:26:36:68 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 scope global docker_gwbridge</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:42ff:fe26:3668/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">docker网络       </span><br><span class="line">$ docker <span class="builtin-name">run</span> -it <span class="attribute">--net</span>=host  busybox</span><br><span class="line">/ #<span class="built_in"> ip </span>a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000</span><br><span class="line">    link/ether 52:54:b9:09:ff:bd brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.1.2/24 brd 172.16.1.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:b9ff:fe09:ffbd/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:fb:c9:10:09 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:fbff:fec9:1009/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">10: docker_gwbridge: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:42:26:36:68 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 scope global docker_gwbridge</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:42ff:fe26:3668/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></p><ul><li>none</li></ul><p>在这种模式下，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信，只有一个会换网卡地址。需要我们自己为Docker容器添加网卡、配置IP等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="builtin-name">run</span> -it <span class="attribute">--net</span>=none  busybox</span><br><span class="line">/ #<span class="built_in"> ip </span>a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><ul><li>container</li></ul><p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">创建box1</span><br><span class="line"></span><br><span class="line">root@k8s-master:~# docker <span class="builtin-name">run</span> -it -d --name box1 busybox</span><br><span class="line">3a7663f170aa6d5ce67e221b1e015a89fcd24b4968c92ddc33875799ee777902</span><br><span class="line"></span><br><span class="line">创建box2，并用container网络链接box1</span><br><span class="line"></span><br><span class="line">root@k8s-master:~# docker <span class="builtin-name">run</span> -it -d --name box2 <span class="attribute">--net</span>=container:box1 busybox</span><br><span class="line">06d4c317f5b099c89c99024fee1d0b691d1d5e586d29a3e81c3150783bdabff5</span><br><span class="line"></span><br><span class="line">查看两个容器网络，会发现他们的网络是一样的，公用namespace</span><br><span class="line"></span><br><span class="line">$ docker exec box1<span class="built_in"> ip </span>addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">17: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">$ docker exec box2<span class="built_in"> ip </span>addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">17: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><ul><li>bridge</li></ul><p>bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。docker安装时，默认会创建一个brdge网络，名称为docker0.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">查看bridge，interfaces是空的</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name<span class="built_in">bridge </span>idSTP enabledinterfaces</span><br><span class="line">docker08000.024230bab5b8<span class="literal">no</span></span><br><span class="line"></span><br><span class="line">深入bridge网络。</span><br><span class="line">$ docker inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"02419aedaf4b936f85bb836d6ff3c3b34f1cb62a8e41f613e33c406343b329c5"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-12-18T11:26:43.870068868+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;</span><br><span class="line">            <span class="string">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.driver.mtu"</span>: <span class="string">"1500"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>现在启动两个容器，看下bridge的变化。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">两个容器已经启动</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">51c530237bf6        busybox             <span class="string">"sh"</span>                3 seconds ago       Up 3 seconds                            stupefied_swartz</span><br><span class="line">1a0a3148c086        busybox             <span class="string">"sh"</span>                7 seconds ago       Up 6 seconds                            condescending_lalande</span><br><span class="line"></span><br><span class="line">查看bridge，已经有两个interface，正是两个容器的网络接入</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name<span class="built_in">bridge </span>idSTP enabledinterfaces</span><br><span class="line">docker08000.024230bab5b8<span class="literal">no</span>veth688fdfd</span><br><span class="line">veth7a1077a</span><br><span class="line"></span><br><span class="line">深入查看，可以看到容器的IP地址等。</span><br><span class="line">root@k8s-node1:~# docker inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"02419aedaf4b936f85bb836d6ff3c3b34f1cb62a8e41f613e33c406343b329c5"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-12-18T11:26:43.870068868+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"1a0a3148c0864d19e7f0e6cdba8f00c40dc6726ba2df6c80d62b95eae814ef34"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"condescending_lalande"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"ba380b01c2f9ec4de630e695a79c66a24f3aaddc3de6fd3e225d1d4a5134355e"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"172.17.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"51c530237bf6bd9fbc806f2396b2c636074ec86be7b106971b58ef4ea71d261b"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"stupefied_swartz"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"82e72c785f0b3f5feaca08baab071582c4dda475beb3d07eb9a632d7893200f2"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:03"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"172.17.0.3/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;</span><br><span class="line">            <span class="string">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.driver.mtu"</span>: <span class="string">"1500"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">查看容器的路由，会发现默认网关都是172.17.0.1,这个地址正式docker0的地址。</span><br><span class="line">$ docker exec stupefied_swartz<span class="built_in"> ip </span>route</span><br><span class="line">default via 172.17.0.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0 scope link  src 172.17.0.3</span><br><span class="line"></span><br><span class="line">查看docker0的ip地址。</span><br><span class="line">$ ifconfig docker0</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:30:ba:b5:b8</span><br><span class="line">          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:30ff:feba:b5b8/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:648 (648.0 B)</span><br></pre></td></tr></table></figure><h4 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h4><p>从上图可以发现:</p><ul><li>docker0就是一个虚拟交换机</li><li>每个容器都会和主机创建一对儿虚拟网卡veth pair，一端就是docker的eth0，另一端就是容器的eth0网卡。</li><li>bridge网络内部是可以通信的，当然通过设置也能组织通信</li><li>docker网卡后面的数字是指与主机网卡的对应的编号，例如：（就是前面的 7，这样就能发现对于关系）</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>: veth7a1077a<span class="meta">@if</span><span class="number">6:</span> &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc noqueue master docker0 state UP group <span class="keyword">default</span></span><br><span class="line">    link/ether <span class="number">46</span>:<span class="string">a7:</span><span class="string">aa:</span><span class="string">ef:</span><span class="number">27</span>:<span class="number">59</span> brd <span class="string">ff:</span><span class="string">ff:</span><span class="string">ff:</span><span class="string">ff:</span><span class="string">ff:</span>ff link-netnsid <span class="number">1</span></span><br><span class="line">    inet6 <span class="string">fe80:</span>:<span class="number">44</span><span class="string">a7:</span><span class="string">aaff:</span><span class="string">feef:</span><span class="number">2759</span>/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h4 id="访问外网"><a href="#访问外网" class="headerlink" title="访问外网"></a>访问外网</h4><p><img src="/images/bridge.png" alt=""></p><p>上面的拓扑关系说明了容器与主机是怎么通信的。那么是怎么访问外网的呢? 其实很简单，就是通过iptables。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain POSTROUTING (policy ACCEPT <span class="number">145</span> packets, <span class="number">13093</span> bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> MASQUERADE  all  --  *      !docker0  <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span>        <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。</p><p>同样的，外部访问容器的服务，也是通过iptables的DNAT映射。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -d -p80:<span class="number">80</span> busybox</span><br><span class="line">3e64200eb3a78a91797ce8b108576285dd0e962bd19244e6099f8203acdb33f9</span><br><span class="line">root@k8s-node1:~# iptables -t nat  -L -n -v</span><br><span class="line">Chain PREROUTING (policy ACCEPT <span class="number">0</span> packets, <span class="number">0</span> bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     <span class="keyword">out</span>     source               destination</span><br><span class="line">    <span class="number">7</span>   <span class="number">424</span> DOCKER     all  --  *      *       <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span>            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT <span class="number">0</span> packets, <span class="number">0</span> bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     <span class="keyword">out</span>     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT <span class="number">0</span> packets, <span class="number">0</span> bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     <span class="keyword">out</span>     source               destination</span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> DOCKER     all  --  *      *       <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span>           !<span class="number">127.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">8</span>          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT <span class="number">0</span> packets, <span class="number">0</span> bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     <span class="keyword">out</span>     source               destination</span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> MASQUERADE  all  --  *      !docker0  <span class="number">172.17</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">16</span>        <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span></span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> MASQUERADE  tcp  --  *      *       <span class="number">172.17</span><span class="meta">.0</span><span class="meta">.4</span>           <span class="number">172.17</span><span class="meta">.0</span><span class="meta">.4</span>           tcp dpt:<span class="number">80</span></span><br><span class="line"></span><br><span class="line">Chain DOCKER (<span class="number">2</span> references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     <span class="keyword">out</span>     source               destination</span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> RETURN     all  --  docker0 *       <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span></span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> DNAT       tcp  --  !docker0 *       <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>/<span class="number">0</span>            tcp dpt:<span class="number">80</span> to:<span class="number">172.17</span><span class="meta">.0</span><span class="meta">.4</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice</a></p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/19/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%80/#disqus_thread</comments>
    </item>
    
    <item>
      <title>sysbench测试磁盘IO</title>
      <link>http://blog.loveops.com/2017/12/08/sysbench%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98IO/</link>
      <guid>http://blog.loveops.com/2017/12/08/sysbench%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98IO/</guid>
      <pubDate>Fri, 08 Dec 2017 14:53:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;前面已经介绍了sysbench的参数，本文介绍使用sysbench测试磁盘io&quot;&gt;&lt;a href=&quot;#前面已经介绍了sysbench的参数，本文介绍使用sysbench测试磁盘io&quot; class=&quot;headerlink&quot; title=&quot;前面已经介绍了sysbenc
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="前面已经介绍了sysbench的参数，本文介绍使用sysbench测试磁盘io"><a href="#前面已经介绍了sysbench的参数，本文介绍使用sysbench测试磁盘io" class="headerlink" title="前面已经介绍了sysbench的参数，本文介绍使用sysbench测试磁盘io"></a>前面已经介绍了sysbench的参数，本文介绍使用sysbench测试磁盘io</h3><h4 id="环境介绍："><a href="#环境介绍：" class="headerlink" title="环境介绍："></a>环境介绍：</h4><ul><li>系统：ubuntu16.04 （青云虚拟机）</li><li>内存：16G</li><li>cpu : 8核心</li><li>sysbench版本：1.0.10</li></ul><h4 id="fileio的基本参数："><a href="#fileio的基本参数：" class="headerlink" title="fileio的基本参数："></a>fileio的基本参数：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench fileio help</span><br><span class="line">sysbench 1.0.10 (using bundled LuaJIT 2.1.0-beta2)</span><br><span class="line"></span><br><span class="line">fileio options:</span><br><span class="line">  <span class="attribute">--file-num</span>=N              创建文件数量，默认 [128]</span><br><span class="line">  <span class="attribute">--file-block-size</span>=N       测试使用块儿大小，默认 [16384]</span><br><span class="line">  <span class="attribute">--file-total-size</span>=SIZE    测试使用文件总大小，默认 [2G]</span><br><span class="line">  <span class="attribute">--file-test-mode</span>=STRING   测试模式 &#123;seqwr（顺序写））, seqrewr（顺序读写）, seqrd（顺序读）, rndrd（随机读）, rndwr（随机写）, rndrw(随机读写)&#125;</span><br><span class="line">  <span class="attribute">--file-io-mode</span>=STRING     文件操操纵模式 &#123;sync（同步）,async（异步）,mmap（快速map映射））&#125;默认 [sync]</span><br><span class="line">  <span class="attribute">--file-async-backlog</span>=N    number of asynchronous operatons <span class="keyword">to</span><span class="built_in"> queue </span>per thread [128]</span><br><span class="line">  <span class="attribute">--file-extra-flags</span>=STRING 使用额外的标志符来打开文件 &#123;sync,dsync,direct&#125; []</span><br><span class="line">  <span class="attribute">--file-fsync-freq</span>=N       在完成N次请求之后，执行fsync()，0表示不使用fsync，默认值：100。</span><br><span class="line">  --file-fsync-all[=on|off] 每次写操作后执行fsync()，默认值：off</span><br><span class="line">  --file-fsync-end[=on|off] 测试结束后执行fsync()，默认值：on。</span><br><span class="line">  <span class="attribute">--file-fsync-mode</span>=STRING  使用fsync或fdatasync方法进行同步，默认值：fsync。</span><br><span class="line">  <span class="attribute">--file-merged-requests</span>=N  m尽可能的合并N个IO请求数，0表示不合并，默认值：0。</span><br><span class="line">  <span class="attribute">--file-rw-ratio</span>=N         测试时候的读写比例，默认值：1.5(即3:2)。</span><br></pre></td></tr></table></figure><h4 id="测试分为三个阶段"><a href="#测试分为三个阶段" class="headerlink" title="测试分为三个阶段"></a>测试分为三个阶段</h4><ul><li>准备（prepare),为测试准备数据</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> sysbench  fileio --<span class="keyword">file</span>-total-size=<span class="number">8</span>G --<span class="keyword">file</span>-num=<span class="number">8</span> prepare</span><br><span class="line">sysbench <span class="number">1.0</span><span class="number">.10</span> (<span class="keyword">using</span> bundled LuaJIT <span class="number">2.1</span><span class="number">.0</span>-beta2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Removing</span></span> test <span class="keyword">files</span>...</span><br><span class="line">root@i-byqycf1n:/fileios# sysbench  fileio --<span class="keyword">file</span>-total-size=<span class="number">8</span>G --<span class="keyword">file</span>-num=<span class="number">8</span> prepare</span><br><span class="line">sysbench <span class="number">1.0</span><span class="number">.10</span> (<span class="keyword">using</span> bundled LuaJIT <span class="number">2.1</span><span class="number">.0</span>-beta2)</span><br><span class="line"></span><br><span class="line"><span class="number">8</span> <span class="keyword">files</span>, <span class="number">1048576</span>Kb each, <span class="number">8192</span>Mb total</span><br><span class="line"><span class="function"><span class="title">Creating</span></span> <span class="keyword">files</span> <span class="keyword">for</span> the test...</span><br><span class="line">Extra <span class="keyword">file</span> open flags: <span class="number">0</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.0</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.1</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.2</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.3</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.4</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.5</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.6</span></span><br><span class="line">Creating <span class="keyword">file</span> test_file<span class="number">.7</span></span><br><span class="line"><span class="number">8589934592</span> bytes written in <span class="number">77.55</span> seconds (<span class="number">105.63</span> MiB/sec).</span><br></pre></td></tr></table></figure><ul><li>测试（run）</li></ul><blockquote><ol><li>随机读写</li></ol></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench fileio <span class="comment">--file-total-size=8G --file-num=8 --file-test-mode=rndrw --time=1800 --file-rw-ratio=1 --threads=16  run</span></span><br><span class="line">sysbench <span class="number">1.0</span><span class="number">.10</span> (<span class="keyword">using</span> bundled LuaJIT <span class="number">2.1</span><span class="number">.0</span>-beta2)</span><br><span class="line"></span><br><span class="line">Running <span class="keyword">the</span> test <span class="keyword">with</span> following options:</span><br><span class="line">Number <span class="keyword">of</span> threads: <span class="number">16</span></span><br><span class="line">Initializing <span class="built_in">random</span> <span class="built_in">number</span> generator <span class="built_in">from</span> current <span class="built_in">time</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Extra <span class="built_in">file</span> <span class="built_in">open</span> flags: <span class="number">0</span></span><br><span class="line"><span class="number">8</span> <span class="built_in">files</span>, <span class="number">1</span>GiB <span class="keyword">each</span></span><br><span class="line"><span class="number">8</span>GiB total <span class="built_in">file</span> size</span><br><span class="line">Block size <span class="number">16</span>KiB</span><br><span class="line">Number <span class="keyword">of</span> IO requests: <span class="number">0</span></span><br><span class="line">Read/Write ratio <span class="keyword">for</span> combined <span class="built_in">random</span> IO test: <span class="number">1.00</span></span><br><span class="line">Periodic FSYNC enabled, calling fsync() <span class="keyword">each</span> <span class="number">100</span> requests.</span><br><span class="line">Calling fsync() <span class="keyword">at</span> <span class="keyword">the</span> <span class="function"><span class="keyword">end</span> <span class="title">of</span> <span class="title">test</span>, <span class="title">Enabled</span>.</span></span><br><span class="line">Using synchronous I/O mode</span><br><span class="line">Doing <span class="built_in">random</span> r/w test</span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">File operations:</span><br><span class="line">    reads/s:                      <span class="number">2000.70</span></span><br><span class="line">    writes/s:                     <span class="number">2000.70</span></span><br><span class="line">    fsyncs/s:                     <span class="number">320.11</span></span><br><span class="line"></span><br><span class="line">Throughput:</span><br><span class="line">    <span class="built_in">read</span>, MiB/s:                  <span class="number">31.26</span></span><br><span class="line">    written, MiB/s:               <span class="number">31.26</span></span><br><span class="line"></span><br><span class="line">General statistics:</span><br><span class="line">    total <span class="built_in">time</span>:                          <span class="number">1800.0141</span>s</span><br><span class="line">    total <span class="built_in">number</span> <span class="keyword">of</span> events:              <span class="number">7778808</span></span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         <span class="built_in">min</span>:                                  <span class="number">0.00</span></span><br><span class="line">         <span class="built_in">avg</span>:                                  <span class="number">3.70</span></span><br><span class="line">         <span class="built_in">max</span>:                                <span class="number">465.40</span></span><br><span class="line">         <span class="number">95</span>th percentile:                      <span class="number">9.56</span></span><br><span class="line">         <span class="built_in">sum</span>:                            <span class="number">28782042.44</span></span><br><span class="line"></span><br><span class="line">Threads fairness:</span><br><span class="line">    events (<span class="built_in">avg</span>/stddev):           <span class="number">486175.5000</span>/<span class="number">1821.33</span></span><br><span class="line">    execution <span class="built_in">time</span> (<span class="built_in">avg</span>/stddev):   <span class="number">1798.8777</span>/<span class="number">0.02</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>顺序读写</li></ol></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench fileio --<span class="keyword">file</span>-total-size=<span class="number">8</span>G --<span class="keyword">file</span>-num=<span class="number">8</span> --<span class="keyword">file</span>-test-<span class="keyword">mode</span>=seqrewr --time=<span class="number">600</span> --<span class="keyword">file</span>-rw-ratio=<span class="number">1</span> --threads=<span class="number">16</span>  run</span><br><span class="line">sysbench <span class="number">1.0</span>.<span class="number">10</span> (using bundled LuaJIT <span class="number">2.1</span>.<span class="number">0</span>-beta2)</span><br><span class="line"></span><br><span class="line">Running the test with following option<span class="variable">s:</span></span><br><span class="line">Number of thread<span class="variable">s:</span> <span class="number">16</span></span><br><span class="line">Initializing random <span class="keyword">number</span> generator from current time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Extra <span class="keyword">file</span> <span class="keyword">open</span> flag<span class="variable">s:</span> <span class="number">0</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">files</span>, <span class="number">1</span>GiB each</span><br><span class="line"><span class="number">8</span>GiB total <span class="keyword">file</span> size</span><br><span class="line">Block size <span class="number">16</span>KiB</span><br><span class="line">Periodic FSYNC enabled, calling fsync() each <span class="number">100</span> requests.</span><br><span class="line">Calling fsync() at the end of test, Enabled.</span><br><span class="line">Using synchronous I/O <span class="keyword">mode</span></span><br><span class="line">Doing sequential rewrite test</span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">File operation<span class="variable">s:</span></span><br><span class="line">    reads/<span class="variable">s:</span>                      <span class="number">0.00</span></span><br><span class="line">    writes/<span class="variable">s:</span>                     <span class="number">8186.76</span></span><br><span class="line">    fsyncs/<span class="variable">s:</span>                     <span class="number">654.93</span></span><br><span class="line"></span><br><span class="line">Throughpu<span class="variable">t:</span></span><br><span class="line">    <span class="keyword">read</span>, MiB/<span class="variable">s:</span>                  <span class="number">0.00</span></span><br><span class="line">    written, MiB/<span class="variable">s:</span>               <span class="number">127.92</span></span><br><span class="line"></span><br><span class="line">General statistic<span class="variable">s:</span></span><br><span class="line">    total time:                          <span class="number">600.1619</span>s</span><br><span class="line">    total <span class="keyword">number</span> of event<span class="variable">s:</span>              <span class="number">5306467</span></span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         <span class="built_in">min</span>:                                  <span class="number">0.00</span></span><br><span class="line">         av<span class="variable">g:</span>                                  <span class="number">1.81</span></span><br><span class="line">         <span class="built_in">max</span>:                                <span class="number">277.45</span></span><br><span class="line">         <span class="number">95</span><span class="keyword">th</span> percentile:                      <span class="number">0.75</span></span><br><span class="line">         sum:                            <span class="number">9597820.52</span></span><br><span class="line"></span><br><span class="line">Threads fairnes<span class="variable">s:</span></span><br><span class="line">    events (avg/stddev):           <span class="number">331654.1875</span>/<span class="number">4172.73</span></span><br><span class="line">    execution time (avg/stddev):   <span class="number">599.8638</span>/<span class="number">0.01</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>顺序写</li></ol></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench fileio --<span class="keyword">file</span>-total-size=<span class="number">8</span>G --<span class="keyword">file</span>-num=<span class="number">8</span> --<span class="keyword">file</span>-test-<span class="keyword">mode</span>=seqwr --time=<span class="number">600</span> --<span class="keyword">file</span>-rw-ratio=<span class="number">1</span> --threads=<span class="number">16</span>  run</span><br><span class="line">sysbench <span class="number">1.0</span>.<span class="number">10</span> (using bundled LuaJIT <span class="number">2.1</span>.<span class="number">0</span>-beta2)</span><br><span class="line"></span><br><span class="line">Running the test with following option<span class="variable">s:</span></span><br><span class="line">Number of thread<span class="variable">s:</span> <span class="number">16</span></span><br><span class="line">Initializing random <span class="keyword">number</span> generator from current time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Extra <span class="keyword">file</span> <span class="keyword">open</span> flag<span class="variable">s:</span> <span class="number">0</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">files</span>, <span class="number">1</span>GiB each</span><br><span class="line"><span class="number">8</span>GiB total <span class="keyword">file</span> size</span><br><span class="line">Block size <span class="number">16</span>KiB</span><br><span class="line">Periodic FSYNC enabled, calling fsync() each <span class="number">100</span> requests.</span><br><span class="line">Calling fsync() at the end of test, Enabled.</span><br><span class="line">Using synchronous I/O <span class="keyword">mode</span></span><br><span class="line">Doing sequential <span class="keyword">write</span> (creation) test</span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">File operation<span class="variable">s:</span></span><br><span class="line">    reads/<span class="variable">s:</span>                      <span class="number">0.00</span></span><br><span class="line">    writes/<span class="variable">s:</span>                     <span class="number">8186.37</span></span><br><span class="line">    fsyncs/<span class="variable">s:</span>                     <span class="number">654.90</span></span><br><span class="line"></span><br><span class="line">Throughpu<span class="variable">t:</span></span><br><span class="line">    <span class="keyword">read</span>, MiB/<span class="variable">s:</span>                  <span class="number">0.00</span></span><br><span class="line">    written, MiB/<span class="variable">s:</span>               <span class="number">127.91</span></span><br><span class="line"></span><br><span class="line">General statistic<span class="variable">s:</span></span><br><span class="line">    total time:                          <span class="number">600.1297</span>s</span><br><span class="line">    total <span class="keyword">number</span> of event<span class="variable">s:</span>              <span class="number">5305927</span></span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         <span class="built_in">min</span>:                                  <span class="number">0.00</span></span><br><span class="line">         av<span class="variable">g:</span>                                  <span class="number">1.81</span></span><br><span class="line">         <span class="built_in">max</span>:                                <span class="number">306.93</span></span><br><span class="line">         <span class="number">95</span><span class="keyword">th</span> percentile:                      <span class="number">0.78</span></span><br><span class="line">         sum:                            <span class="number">9597135.97</span></span><br><span class="line"></span><br><span class="line">Threads fairnes<span class="variable">s:</span></span><br><span class="line">    events (avg/stddev):           <span class="number">331620.4375</span>/<span class="number">5134.81</span></span><br><span class="line">    execution time (avg/stddev):   <span class="number">599.8210</span>/<span class="number">0.01</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>顺序读 </li></ol></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench fileio --<span class="keyword">file</span>-total-size=<span class="number">8</span>G --<span class="keyword">file</span>-num=<span class="number">8</span> --<span class="keyword">file</span>-test-<span class="keyword">mode</span>=seqrd --time=<span class="number">600</span> --<span class="keyword">file</span>-rw-ratio=<span class="number">1</span> --threads=<span class="number">16</span>  run</span><br><span class="line">sysbench <span class="number">1.0</span>.<span class="number">10</span> (using bundled LuaJIT <span class="number">2.1</span>.<span class="number">0</span>-beta2)</span><br><span class="line"></span><br><span class="line">Running the test with following option<span class="variable">s:</span></span><br><span class="line">Number of thread<span class="variable">s:</span> <span class="number">16</span></span><br><span class="line">Initializing random <span class="keyword">number</span> generator from current time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Extra <span class="keyword">file</span> <span class="keyword">open</span> flag<span class="variable">s:</span> <span class="number">0</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">files</span>, <span class="number">1</span>GiB each</span><br><span class="line"><span class="number">8</span>GiB total <span class="keyword">file</span> size</span><br><span class="line">Block size <span class="number">16</span>KiB</span><br><span class="line">Periodic FSYNC enabled, calling fsync() each <span class="number">100</span> requests.</span><br><span class="line">Calling fsync() at the end of test, Enabled.</span><br><span class="line">Using synchronous I/O <span class="keyword">mode</span></span><br><span class="line">Doing sequential <span class="keyword">read</span> test</span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">File operation<span class="variable">s:</span></span><br><span class="line">    reads/<span class="variable">s:</span>                      <span class="number">724368.39</span></span><br><span class="line">    writes/<span class="variable">s:</span>                     <span class="number">0.00</span></span><br><span class="line">    fsyncs/<span class="variable">s:</span>                     <span class="number">0.00</span></span><br><span class="line"></span><br><span class="line">Throughpu<span class="variable">t:</span></span><br><span class="line">    <span class="keyword">read</span>, MiB/<span class="variable">s:</span>                  <span class="number">11318.26</span></span><br><span class="line">    written, MiB/<span class="variable">s:</span>               <span class="number">0.00</span></span><br><span class="line"></span><br><span class="line">General statistic<span class="variable">s:</span></span><br><span class="line">    total time:                          <span class="number">600.0003</span>s</span><br><span class="line">    total <span class="keyword">number</span> of event<span class="variable">s:</span>              <span class="number">434622830</span></span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         <span class="built_in">min</span>:                                  <span class="number">0.00</span></span><br><span class="line">         av<span class="variable">g:</span>                                  <span class="number">0.02</span></span><br><span class="line">         <span class="built_in">max</span>:                                 <span class="number">20.95</span></span><br><span class="line">         <span class="number">95</span><span class="keyword">th</span> percentile:                      <span class="number">0.03</span></span><br><span class="line">         sum:                            <span class="number">6794650.94</span></span><br><span class="line"></span><br><span class="line">Threads fairnes<span class="variable">s:</span></span><br><span class="line">    events (avg/stddev):           <span class="number">27163926.8750</span>/<span class="number">1054351.39</span></span><br><span class="line">    execution time (avg/stddev):   <span class="number">424.6657</span>/<span class="number">2.57</span></span><br></pre></td></tr></table></figure><ul><li>清理测试数据（cleanup）</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> sysbench  fileio --<span class="keyword">file</span>-total-size=<span class="number">8</span>G --<span class="keyword">file</span>-num=<span class="number">8</span> cleanup</span><br><span class="line">sysbench <span class="number">1.0</span><span class="number">.10</span> (<span class="keyword">using</span> bundled LuaJIT <span class="number">2.1</span><span class="number">.0</span>-beta2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Removing</span></span> test <span class="keyword">files</span>...</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/08/sysbench%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98IO/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Logstash处理nginx日志grok配置</title>
      <link>http://blog.loveops.com/2017/12/07/Logstash%E5%A4%84%E7%90%86nginx%E6%97%A5%E5%BF%97grok%E9%85%8D%E7%BD%AE/</link>
      <guid>http://blog.loveops.com/2017/12/07/Logstash%E5%A4%84%E7%90%86nginx%E6%97%A5%E5%BF%97grok%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Thu, 07 Dec 2017 14:08:47 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;nginx日志配置&quot;&gt;&lt;a href=&quot;#nginx日志配置&quot; class=&quot;headerlink&quot; title=&quot;nginx日志配置&quot;&gt;&lt;/a&gt;nginx日志配置&lt;/h4&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="nginx日志配置"><a href="#nginx日志配置" class="headerlink" title="nginx日志配置"></a>nginx日志配置</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>"'</span>;</span><br><span class="line">                      </span><br><span class="line"></span><br><span class="line"><span class="attribute">access_log</span>   /usr/local/var/log/nginx/host.access.log  main;</span><br></pre></td></tr></table></figure><h4 id="logstash配置"><a href="#logstash配置" class="headerlink" title="logstash配置"></a>logstash配置</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; <span class="string">"/usr/local/var/log/nginx/host.access.log"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match =&gt; &#123;</span><br><span class="line">           <span class="string">"message"</span> =&gt; <span class="string">"%&#123;IPV4:client_ip&#125; %&#123;USER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] \"%&#123;WORD:method&#125; %&#123;NOTSPACE:verb&#125; HTTP/%&#123;NUMBER:httpversion&#125;\" %&#123;NUMBER:response&#125; %&#123;NUMBER:bytes&#125; %&#123;QS:referrer&#125; %&#123;QS:agent&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">        remove_field =&gt; [<span class="string">"message"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">       hosts =&gt; [<span class="string">"127.0.0.1:9200"</span>]</span><br><span class="line">       index =&gt; <span class="string">"nginx-access"</span></span><br><span class="line">      <span class="built_in"> user </span>=&gt; <span class="string">"elastic"</span></span><br><span class="line">       password =&gt; <span class="string">"changeme"</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="logstash标准输出"><a href="#logstash标准输出" class="headerlink" title="logstash标准输出"></a>logstash标准输出</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">             <span class="string">"agent"</span> =&gt; <span class="string">"\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\""</span>,</span><br><span class="line">             <span class="string">"geoip"</span> =&gt; &#123;</span><br><span class="line">              <span class="string">"timezone"</span> =&gt; <span class="string">"Asia/Tokyo"</span>,</span><br><span class="line">                    <span class="string">"ip"</span> =&gt; <span class="string">"139.162.114.70"</span>,</span><br><span class="line">              <span class="string">"latitude"</span> =&gt; <span class="number">35.6427</span>,</span><br><span class="line">        <span class="string">"continent_code"</span> =&gt; <span class="string">"AS"</span>,</span><br><span class="line">             <span class="string">"city_name"</span> =&gt; <span class="string">"Tokyo"</span>,</span><br><span class="line">          <span class="string">"country_name"</span> =&gt; <span class="string">"Japan"</span>,</span><br><span class="line">         <span class="string">"country_code2"</span> =&gt; <span class="string">"JP"</span>,</span><br><span class="line">         <span class="string">"country_code3"</span> =&gt; <span class="string">"JP"</span>,</span><br><span class="line">           <span class="string">"region_name"</span> =&gt; <span class="string">"Tokyo"</span>,</span><br><span class="line">              <span class="string">"location"</span> =&gt; &#123;</span><br><span class="line">            <span class="string">"lon"</span> =&gt; <span class="number">139.7677</span>,</span><br><span class="line">            <span class="string">"lat"</span> =&gt; <span class="number">35.6427</span></span><br><span class="line">        &#125;,</span><br><span class="line">           <span class="string">"postal_code"</span> =&gt; <span class="string">"100-0001"</span>,</span><br><span class="line">           <span class="string">"region_code"</span> =&gt; <span class="string">"13"</span>,</span><br><span class="line">             <span class="string">"longitude"</span> =&gt; <span class="number">139.7677</span></span><br><span class="line">    &#125;,</span><br><span class="line">            <span class="string">"method"</span> =&gt; <span class="string">"GET"</span>,</span><br><span class="line">              <span class="string">"auth"</span> =&gt; <span class="string">"-"</span>,</span><br><span class="line">             <span class="string">"ident"</span> =&gt; <span class="string">"-"</span>,</span><br><span class="line">              <span class="string">"verb"</span> =&gt; <span class="string">"/"</span>,</span><br><span class="line">    <span class="string">"read_timestamp"</span> =&gt; <span class="string">"2017-12-07T02:10:42.947Z"</span>,</span><br><span class="line">              <span class="string">"path"</span> =&gt; <span class="string">"/usr/local/var/log/nginx/host.access.log"</span>,</span><br><span class="line">          <span class="string">"referrer"</span> =&gt; <span class="string">"\"http://118.193.143.23:80/\""</span>,</span><br><span class="line">        <span class="string">"@timestamp"</span> =&gt; <span class="number">2017</span><span class="number">-12</span><span class="number">-07</span>T02:<span class="number">10</span>:<span class="number">42.947</span>Z,</span><br><span class="line">          <span class="string">"response"</span> =&gt; <span class="string">"200"</span>,</span><br><span class="line">             <span class="string">"bytes"</span> =&gt; <span class="string">"56733"</span>,</span><br><span class="line">          <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">              <span class="string">"host"</span> =&gt; <span class="string">"hanjh-MacBook-Pro.local"</span>,</span><br><span class="line">         <span class="string">"client_ip"</span> =&gt; <span class="string">"139.162.114.70"</span>,</span><br><span class="line">       <span class="string">"httpversion"</span> =&gt; <span class="string">"1.1"</span>,</span><br><span class="line">         <span class="string">"timestamp"</span> =&gt; <span class="string">"07/Dec/2017:07:46:51 +0800"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：geoip对127.0.0.1匹配不到，测试的时候可以找个公网ip，echo到日志文件中。</p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/07/Logstash%E5%A4%84%E7%90%86nginx%E6%97%A5%E5%BF%97grok%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python 抓取系统CPU负责和内存信息</title>
      <link>http://blog.loveops.com/2017/12/01/Python-%E6%8A%93%E5%8F%96%E7%B3%BB%E7%BB%9FCPU%E8%B4%9F%E8%B4%A3%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/</link>
      <guid>http://blog.loveops.com/2017/12/01/Python-%E6%8A%93%E5%8F%96%E7%B3%BB%E7%BB%9FCPU%E8%B4%9F%E8%B4%A3%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/</guid>
      <pubDate>Fri, 01 Dec 2017 15:03:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;CPU负载&quot;&gt;&lt;a href=&quot;#CPU负载&quot; class=&quot;headerlink&quot; title=&quot;CPU负载&quot;&gt;&lt;/a&gt;CPU负载&lt;/h3&gt;&lt;figure class=&quot;highlight prolog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="CPU负载"><a href="#CPU负载" class="headerlink" title="CPU负载"></a>CPU负载</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">f = open(<span class="string">'/proc/loadavg'</span>)</span><br><span class="line">l = f.read().split()</span><br><span class="line">f.close()</span><br><span class="line"> </span><br><span class="line">dic =  &#123;&#125;</span><br><span class="line">def load_stat():</span><br><span class="line">    dic[<span class="string">"lavg_1"</span>]=l[<span class="number">0</span>]</span><br><span class="line">    dic[<span class="string">"lavg_5"</span>]=l[<span class="number">1</span>]</span><br><span class="line">    dic[<span class="string">"lavg_15"</span>]=l[<span class="number">2</span>]</span><br><span class="line">    dic[<span class="string">"nr"</span>]=l[<span class="number">3</span>]</span><br><span class="line">    dic[<span class="string">"last_pid"</span>]=l[<span class="number">4</span>]</span><br><span class="line">    return dic</span><br><span class="line"> </span><br><span class="line">print <span class="string">"loadavg"</span>,load_stat()[<span class="string">"lavg_15"</span>]</span><br></pre></td></tr></table></figure><h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env Python</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">meminfo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">''' Return the information in /proc/meminfo</span></span><br><span class="line"><span class="string">    as a dictionary '''</span></span><br><span class="line">    meminfo=OrderedDict()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/proc/meminfo'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            meminfo[line.split(<span class="string">':'</span>)[<span class="number">0</span>]] = line.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> meminfo</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#print(meminfo())</span></span><br><span class="line">     </span><br><span class="line">    meminfo = meminfo()</span><br><span class="line">    print(<span class="string">'Total memory: &#123;0&#125;'</span>.format(meminfo[<span class="string">'MemTotal'</span>]))</span><br><span class="line">    print(<span class="string">'Free memory: &#123;0&#125;'</span>.format(meminfo[<span class="string">'MemFree'</span>]))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/01/Python-%E6%8A%93%E5%8F%96%E7%B3%BB%E7%BB%9FCPU%E8%B4%9F%E8%B4%A3%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>配置php和nginx环境</title>
      <link>http://blog.loveops.com/2017/12/01/%E9%85%8D%E7%BD%AEphp%E5%92%8Cnginx%E7%8E%AF%E5%A2%83/</link>
      <guid>http://blog.loveops.com/2017/12/01/%E9%85%8D%E7%BD%AEphp%E5%92%8Cnginx%E7%8E%AF%E5%A2%83/</guid>
      <pubDate>Fri, 01 Dec 2017 15:00:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统版本： ubuntu 16.04 64bit&lt;/li&gt;
&lt;li&gt;php版本： 7.0.26&lt;/li&gt;
&lt;li
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h4><ul><li>系统版本： ubuntu 16.04 64bit</li><li>php版本： 7.0.26</li><li>nginx版本：nginx/1.10.3</li></ul><h4 id="安装环境依赖"><a href="#安装环境依赖" class="headerlink" title="安装环境依赖"></a>安装环境依赖</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">install</span> gcc libxml2-dev nginx  make  -y</span><br></pre></td></tr></table></figure><h4 id="编译安装php"><a href="#编译安装php" class="headerlink" title="编译安装php"></a>编译安装php</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf php-7.0.26.tar.gz</span><br><span class="line"><span class="keyword">cd</span> <span class="string">../php-7.0.26</span></span><br><span class="line"><span class="string">./configure</span> <span class="params">--enable-fpm</span> <span class="params">--with-mysql</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="配置php为系统服务"><a href="#配置php为系统服务" class="headerlink" title="配置php为系统服务"></a>配置php为系统服务</h4><h5 id="拷贝服务脚本到系统服务目录"><a href="#拷贝服务脚本到系统服务目录" class="headerlink" title="拷贝服务脚本到系统服务目录"></a>拷贝服务脚本到系统服务目录</h5><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /root/php-<span class="number">7.0</span>.<span class="number">26</span>/sapi/fpm/php-fpm.service  /<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/</span></span><br></pre></td></tr></table></figure><h5 id="查看系统脚本信息"><a href="#查看系统脚本信息" class="headerlink" title="查看系统脚本信息"></a>查看系统脚本信息</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl cat php-fpm.service</span><br><span class="line"><span class="comment"># /lib/systemd/system/php-fpm.service</span></span><br><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=The PHP FastCGI Process Manager</span><br><span class="line"><span class="attribute">After</span>=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=simple</span><br><span class="line"><span class="attribute">PIDFile</span>=/usr/local/var/run/php-fpm.pid</span><br><span class="line"><span class="attribute">ExecStart</span>=/usr/local/sbin/php-fpm --nodaemonize --fpm-config /usr/local/etc/php-fpm.conf</span><br><span class="line"><span class="attribute">ExecReload</span>=/bin/kill -USR2 <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><h5 id="拷贝配置文件"><a href="#拷贝配置文件" class="headerlink" title="拷贝配置文件"></a>拷贝配置文件</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/usr/local/etc</span><br><span class="line">$ cp php-fpm<span class="selector-class">.conf</span><span class="selector-class">.default</span> php-fpm.conf</span><br><span class="line">$ cp php-fpm.d/www<span class="selector-class">.conf</span><span class="selector-class">.default</span> php-fpm.d/www.conf</span><br></pre></td></tr></table></figure><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/usr/local/etc</span><br><span class="line">vim php-fpm.conf</span><br><span class="line"><span class="attribute">include</span>=etc/php-fpm.d/*.conf ##修改最后一行</span><br><span class="line"></span><br><span class="line">vim php-fpm.d/www.conf</span><br><span class="line">user = www-data</span><br><span class="line">group = www-data  ##修改用户和用户组</span><br></pre></td></tr></table></figure><h4 id="加载php系统服务并启动"><a href="#加载php系统服务并启动" class="headerlink" title="加载php系统服务并启动"></a>加载php系统服务并启动</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl start php-fpm.service</span><br><span class="line">$ systemctl status php-fpm.service</span><br><span class="line">● php-fpm.service - The PHP FastCGI Process Manager</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/php-fpm.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Sat 2017-12-09 22:04:09 CST; 36min ago</span><br><span class="line"> Main PID: 27197 (php-fpm)</span><br><span class="line">   CGroup: /system.slice/php-fpm.service</span><br><span class="line">           ├─27197 php-fpm: master process (/usr/local/etc/php-fpm.conf)</span><br><span class="line">           ├─27199 php-fpm:<span class="built_in"> pool </span>www</span><br><span class="line">           └─27200 php-fpm:<span class="built_in"> pool </span>www</span><br><span class="line"></span><br><span class="line">Dec 09 22:04:09 i-byqycf1n systemd[1]: Started The PHP FastCGI Process Manager.</span><br><span class="line">Dec 09 22:40:24 i-byqycf1n systemd[1]: Started The PHP FastCGI Process Manager.</span><br></pre></td></tr></table></figure><h4 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="meta-keyword">/etc/</span>nginx<span class="meta-keyword">/sites-available/</span>default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">                include snippets/fastcgi-php.conf;</span><br><span class="line">        <span class="meta">#</span></span><br><span class="line">        <span class="meta">#       # With php7.0-cgi alone:</span></span><br><span class="line">                fastcgi_pass <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span>;</span><br><span class="line">        <span class="meta">#       # With php7.0-fpm:</span></span><br><span class="line">        <span class="meta">#       fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">$ nginx -t</span><br><span class="line"><span class="symbol">nginx:</span> the configuration file <span class="meta-keyword">/etc/</span>nginx/nginx.conf syntax is ok</span><br><span class="line"><span class="symbol">nginx:</span> configuration file <span class="meta-keyword">/etc/</span>nginx/nginx.conf test is successful</span><br><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="创建php测试文件"><a href="#创建php测试文件" class="headerlink" title="创建php测试文件"></a>创建php测试文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "<span class="php"><span class="meta">&lt;?php</span> phpinfo(); <span class="meta">?&gt;</span></span>" &gt;&gt; /var/www/html/index.php</span><br></pre></td></tr></table></figure><h4 id="访问php测试文件"><a href="#访问php测试文件" class="headerlink" title="访问php测试文件"></a>访问php测试文件</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/index.php</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/01/%E9%85%8D%E7%BD%AEphp%E5%92%8Cnginx%E7%8E%AF%E5%A2%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>nginx监控指标</title>
      <link>http://blog.loveops.com/2017/12/01/nginx%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/</link>
      <guid>http://blog.loveops.com/2017/12/01/nginx%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/</guid>
      <pubDate>Fri, 01 Dec 2017 14:54:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;nginx自带有个state监控页面，以下是监控指标。&quot;&gt;&lt;a href=&quot;#nginx自带有个state监控页面，以下是监控指标。&quot; class=&quot;headerlink&quot; title=&quot;nginx自带有个state监控页面，以下是监控指标。&quot;&gt;&lt;/a&gt;ngin
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="nginx自带有个state监控页面，以下是监控指标。"><a href="#nginx自带有个state监控页面，以下是监控指标。" class="headerlink" title="nginx自带有个state监控页面，以下是监控指标。"></a>nginx自带有个state监控页面，以下是监控指标。</h3><table><thead><tr><th>指标</th><th style="text-align:right">说明</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td>nginx.inx.conn.active</td><td style="text-align:right">当前连接数</td><td style="text-align:center">数值</td></tr><tr><td>nginx.conn.reading</td><td style="text-align:right">正在读的连接数</td><td style="text-align:center">数值</td></tr><tr><td>nginx.conn.waiting</td><td style="text-align:right">空闲连接数</td><td style="text-align:center">数值</td></tr><tr><td>nginx.conn.writing</td><td style="text-align:right">正在写的连接数</td><td style="text-align:center">数值</td></tr><tr><td>nginx.req.accept</td><td style="text-align:right">已接受请求数</td><td style="text-align:center">计数器</td></tr><tr><td>nginx.req.handled</td><td style="text-align:right">已处理请求数</td><td style="text-align:center">计数器</td></tr><tr><td>nginx.req.total</td><td style="text-align:right">请求总数</td><td style="text-align:center">计数器</td></tr></tbody></table>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/12/01/nginx%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git钩子实现hexo博客自动部署</title>
      <link>http://blog.loveops.com/2017/11/29/git%E9%92%A9%E5%AD%90%E5%AE%9E%E7%8E%B0hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</link>
      <guid>http://blog.loveops.com/2017/11/29/git%E9%92%A9%E5%AD%90%E5%AE%9E%E7%8E%B0hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</guid>
      <pubDate>Wed, 29 Nov 2017 14:17:30 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;最近用hexo搭建了博客，刚开始用了github-page，后面用了一台云主机。并用git钩子实现了自动部署，以下是步骤：&quot;&gt;&lt;a href=&quot;#最近用hexo搭建了博客，刚开始用了github-page，后面用了一台云主机。并用git钩子实现了自动部署，以下是步
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="最近用hexo搭建了博客，刚开始用了github-page，后面用了一台云主机。并用git钩子实现了自动部署，以下是步骤："><a href="#最近用hexo搭建了博客，刚开始用了github-page，后面用了一台云主机。并用git钩子实现了自动部署，以下是步骤：" class="headerlink" title="最近用hexo搭建了博客，刚开始用了github page，后面用了一台云主机。并用git钩子实现了自动部署，以下是步骤："></a>最近用hexo搭建了博客，刚开始用了github page，后面用了一台云主机。并用git钩子实现了自动部署，以下是步骤：</h4><h4 id="环境主备"><a href="#环境主备" class="headerlink" title="环境主备"></a>环境主备</h4><ul><li>云主机：Ubuntu16.04 git  nginx</li><li>mac（本地主机）hexo 环境</li></ul><h4 id="云主机配置"><a href="#云主机配置" class="headerlink" title="云主机配置"></a>云主机配置</h4><ul><li>安装环境</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1、apt install nginx git -<span class="built_in">y</span></span><br><span class="line"></span><br><span class="line">2、配置nginx</span><br><span class="line"></span><br><span class="line">root@blog:~# <span class="keyword">cat</span> /etc/nginx/sites-available/default</span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name blog.loveops.org;</span><br><span class="line">    rewrite ^/(.*)$ https:<span class="comment">//blog.loveops.org/$1 permanent;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  blog.loveops.org ;</span><br><span class="line"></span><br><span class="line">    charset utf8;</span><br><span class="line">    #access_log  /<span class="keyword">var</span>/<span class="keyword">log</span>/nginx/<span class="keyword">log</span>/host.access.<span class="keyword">log</span>  main;</span><br><span class="line">    ssl  <span class="keyword">on</span>;</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/blog.loveops.org/fullchain.pem; # managed <span class="keyword">by</span> Certbot</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/blog.loveops.org/privkey.pem; # managed <span class="keyword">by</span> Certbot</span><br><span class="line"></span><br><span class="line">    ssl_ciphers 'ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:!aNULL:!eNULL:!EXPORT:!<span class="keyword">DES</span>:!MD5:!PSK:!RC4';</span><br><span class="line">    ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers <span class="keyword">on</span>;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line">    root /opt/blog/;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>git配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、生成一个本地空仓库</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">git init --bare blog.git</span><br><span class="line"></span><br><span class="line">2、配置钩子，生成孔仓库后，在/opt/blog.git/hooks下有很多hooks模板文件，新建一个post-receive，并添加执行权限。</span><br><span class="line"></span><br><span class="line">root@blog:/opt/blog.git/hooks<span class="comment"># cat post-receive</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">unset</span> GIT_DIR</span><br><span class="line"><span class="built_in">cd</span> /opt/blog</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">3、克隆仓库</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> ./blog.git/</span><br><span class="line"></span><br><span class="line">root@blog:/opt<span class="comment"># ls    ##执行后opt文件夹如下</span></span><br><span class="line">blog  blog.git</span><br></pre></td></tr></table></figure><ul><li>Mac（本地笔记本配置）</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、首先配置笔记本到云主机的免密钥登录</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">ssh-copy-id -<span class="selector-tag">i</span> .ssh/id_rsa<span class="selector-class">.pub</span> root@blog<span class="selector-class">.loveops</span><span class="selector-class">.org</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、hexo部署，官方文档说的很清楚，这里不在详说</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、修改hexo配置文件，修改git地址如下：</span><br><span class="line"></span><br><span class="line">➜  loveops git:(master) ✗ tail -n <span class="number">4</span> _config.yml</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: root@blog<span class="selector-class">.loveops</span><span class="selector-class">.org</span>:/opt/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ul><li>hexo提交</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在在mac上编辑markdown文件后，执行一下命令，云主机的blog直接就更新了。</span><br><span class="line"></span><br><span class="line">hexo <span class="keyword">generate</span> &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><ul><li><p>提示</p><p>还可以把hexo文件保存到远端仓库，以后更换笔记本也无所谓</p></li></ul>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/11/29/git%E9%92%A9%E5%AD%90%E5%AE%9E%E7%8E%B0hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Let&#39;s Encrypt生成免费的SSL证书</title>
      <link>http://blog.loveops.com/2017/11/29/Let-s-Encrypt%E7%94%9F%E6%88%90%E5%85%8D%E8%B4%B9%E7%9A%84SSL%E8%AF%81%E4%B9%A6/</link>
      <guid>http://blog.loveops.com/2017/11/29/Let-s-Encrypt%E7%94%9F%E6%88%90%E5%85%8D%E8%B4%B9%E7%9A%84SSL%E8%AF%81%E4%B9%A6/</guid>
      <pubDate>Wed, 29 Nov 2017 05:36:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;Let’s-Encrypt介绍：&quot;&gt;&lt;a href=&quot;#Let’s-Encrypt介绍：&quot; class=&quot;headerlink&quot; title=&quot;Let’s Encrypt介绍：&quot;&gt;&lt;/a&gt;Let’s Encrypt介绍：&lt;/h4&gt;&lt;p&gt;Let’s Encrypt是
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="Let’s-Encrypt介绍："><a href="#Let’s-Encrypt介绍：" class="headerlink" title="Let’s Encrypt介绍："></a>Let’s Encrypt介绍：</h4><p>Let’s Encrypt是一个免费的自动的开发的证书颁发机构，为公众利益儿运行，是一个服务互联网安全研究小组提供。官方网站：<a href="https://letsencrypt.org/" target="_blank" rel="noopener">https://letsencrypt.org/</a></p><h4 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h4><p>Certbot是Let’s Encrypt官方推荐的获取证书的客户端，可以帮我们获取免费的Let’s Encrypt 证书。更多关于CertBot可以访问官方网站：<a href="https://certbot.eff.org" target="_blank" rel="noopener">https://certbot.eff.org</a></p><h4 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h4><p>服务器： Ubuntu16.04<br>webserver：  nginx</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、安装nginx，这里不在介绍，直接apt安装就行</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、安装Cerbot，如果是其他系统或者是webserver可以直接访问 http<span class="variable">s:</span>//certbot.eff.org/ 然后选择自己的系统和webservre软件，就可以直接查看安装文档。</span><br><span class="line"></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install software-properties-common</span><br><span class="line">$ sudo <span class="built_in">add</span>-apt-repository <span class="keyword">pp</span><span class="variable">a:certbot</span>/certbot</span><br><span class="line">$ sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-certbot-nginx</span><br></pre></td></tr></table></figure><h4 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行一下命令，按照提示，一步一步来就行，有一点要注意，服务器的<span class="number">443</span>端口要能访问，并且没被占用。</span><br><span class="line"></span><br><span class="line">certbot --nginx  </span><br><span class="line"></span><br><span class="line">这条命令certbot会直接在nginx配置文件添加ssl配置：</span><br><span class="line"></span><br><span class="line">ssl_certificate <span class="meta-keyword">/etc/</span>letsencrypt<span class="meta-keyword">/live/</span>blog.loveops.org/fullchain.pem; <span class="meta"># managed by Certbot</span></span><br><span class="line">ssl_certificate_key <span class="meta-keyword">/etc/</span>letsencrypt<span class="meta-keyword">/live/</span>blog.loveops.org/privkey.pem; <span class="meta"># managed by Certbot</span></span><br><span class="line"></span><br><span class="line">如果你不想让certbot直接操作配置文件，可以执行以下配置文件：</span><br><span class="line"></span><br><span class="line">certbot --nginx certonly</span><br><span class="line"></span><br><span class="line">这条命令会在以下文件夹<span class="meta-keyword">/etc/</span>letsencrypt<span class="meta-keyword">/live/</span>blog.loveops.org/生成证书文件</span><br><span class="line"></span><br><span class="line">root@blog:~<span class="meta"># ls  /etc/letsencrypt/live/blog.loveops.org/</span></span><br><span class="line">cert.pem  chain.pem  fullchain.pem  privkey.pem  README</span><br></pre></td></tr></table></figure><h4 id="证书自动更新"><a href="#证书自动更新" class="headerlink" title="证书自动更新"></a>证书自动更新</h4><p>Let’s Encrypt 提供的证书只有90天的有效期，我们必须在证书到期之前，重新获取这些证书，certbot 给我们提供了一个很方便的命令，那就是 certbot renew。<br>通过这个命令，他会自动检查系统内的证书，并且自动更新这些证书。<br>我们可以运行这个命令测试一下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --dry-<span class="keyword">run</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>如果以上命令没有问题，可以写个 crontab计划任务。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">certbot </span><span class="string">renew </span><span class="built_in">--pre-hook</span> <span class="string">"service nginx stop"</span> <span class="built_in">--post-hook</span> <span class="string">"service nginx start"</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/11/29/Let-s-Encrypt%E7%94%9F%E6%88%90%E5%85%8D%E8%B4%B9%E7%9A%84SSL%E8%AF%81%E4%B9%A6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ElasticSearch-Index和Type的区别</title>
      <link>http://blog.loveops.com/2017/11/27/ElasticSearch-Index%E5%92%8CType%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <guid>http://blog.loveops.com/2017/11/27/ElasticSearch-Index%E5%92%8CType%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <pubDate>Mon, 27 Nov 2017 13:34:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;对于 ES 的新用户来说，有一个常见的问题：要存储一批新的数据时，应该在已有 index 里新建一个 type，还是给它新建一个index？要想回答这个问题，我们必须先理解这两者是怎么实现的。过去，我们为了让 ES更容易理解，经常用关系型数据库做一个比喻： index 就像
        
      
      </description>
      
      <content:encoded><![CDATA[<p>对于 ES 的新用户来说，有一个常见的问题：要存储一批新的数据时，应该在已有 index 里新建一个 type，还是给它新建一个index？要想回答这个问题，我们必须先理解这两者是怎么实现的。过去，我们为了让 ES更容易理解，经常用关系型数据库做一个比喻： index 就像关系型数据库里的 database, type 就像 database 里的 table。但是这并不正确。由于两种数据库存储数据的方式是如此不同，任何比喻都是没有意义的。这种比喻往往会导致对 type 的滥用。</p><h3 id="Index-是什么"><a href="#Index-是什么" class="headerlink" title="Index 是什么"></a>Index 是什么</h3><p>Index 存储在多个分片中，其中每一个分片都是一个独立的 Lucene Index。这就应该能提醒你，添加新 index 应该有个限度：每个 Lucene Index 都需要消耗一些磁盘，内存和文件描述符。因此，一个大的 index 比多个小 index 效率更高：Lucene Index 的固定开销被摊分到更多文档上了。</p><p>另一个重要因素是你准备怎么搜索你的数据。在搜索时，每个分片都需要搜索一次， 然后 ES 会合并来自所有分片的结果。例如，你要搜索 10 个 index，每个 index 有 5 个分片，那么协调这次搜索的节点就需要合并 5x10=50 个分片的结果。这也是一个你需要注意的地方：如果有太多分片的结果需要合并，或者你发起了一个结果巨大的搜索请求，合并任务会需要大量 CPU 和内存资源。这是第二个让 index 少一些的理由。</p><h3 id="Type-是什么"><a href="#Type-是什么" class="headerlink" title="Type 是什么"></a>Type 是什么</h3><p>使用 type 允许我们在一个 index 里存储多种类型的数据，这样就可以减少 index 的数量了。在使用时，向每个文档加入 _type 字段，在指定 type 搜索时就会被用于过滤。使用 type 的一个好处是，搜索一个 index 下的多个 type，和只搜索一个 type 相比没有额外的开销 —— 需要合并结果的分片数量是一样的。</p><p>但是，这也是有限制的：</p><ul><li>不同 type 里的字段需要保持一致。例如，一个 index 下的不同 type 里有两个名字相同的字段，他们的类型（string, date 等等）和配置也必须相同。</li></ul><ul><li>只在某个 type 里存在的字段，在其他没有该字段的 type 中也会消耗资源。这是 Lucene Index 带来的常见问题：它不喜欢稀疏。由于连续文档之间的差异太大，稀疏的 posting list 的压缩效率不高。这个问题在 doc value 上更为严重：为了提高速度，doc value 通常会为每个文档预留一个固定大小的空间，以便文档可以被高速检索。这意味着，如果 Lucene 确定它需要一个字节来存储某个数字类型的字段，它同样会给没有这个字段的文档预留一个字节。未来版本的 ES 会在这方面做一些改进，但是我仍然建议你在建模的时候尽量避免稀疏。[1]</li><li>得分是由 index 内的统计数据来决定的。也就是说，一个 type 中的文档会影响另一个 type 中的文档的得分。<br>这意味着，只有同一个 index 的中的 type 都有类似的映射 (mapping) 时，才应该使用 type。否则，使用多个 type 可能比使用多个 index 消耗的资源更多。</li></ul><h3 id="我应该用哪个"><a href="#我应该用哪个" class="headerlink" title="我应该用哪个"></a>我应该用哪个</h3><p>这是个困难的问题，它的答案取决于你用的硬件、数据和用例。首先你要明白 type 是有用的，因为它能减少 ES 需要管理的 Lucene Index 的数量。但是也有另外一种方式可以减少这个数量：创建 index 的时候让它的分片少一些。例如，与其在一个 index 里塞上 5 个 type，不如创建 5 个只有一个分片的 index。</p><p>在你做决定的时候可以问自己下面几个问题：</p><ul><li>你需要使用父子文档吗？如果需要，只能在一个 index 里建立多个 type。</li><li>你的文档的映射是否相似？如果不相似，使用多个 index。</li><li>如果你的每个 type 都有足够多的文档，Lucene Index 的开销可以被分摊掉，你就可以安全的使用多个 index 了。如果有必要的话，可以把分片数量设小一点。</li><li>如果文档不够多，你可以考虑把文档放进一个 index 里的多个 type 里，甚至放进一个 type 里。  </li></ul><p>总之，你可能有点惊讶，因为 type<br>的使用场景没有你想象的多，这是正确的。由于我们上面提到原因，在一个 index 中使用多个 type 的情景其实很少。如果你的数据有不同的映射，那就给他们分配不同的 index。但是请记住，如果不需要很高的写入吞吐量，或者存储的文档数量不多，你可以通过减少 index 的分片来使集群中的分片数量保持合理。</p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/11/27/ElasticSearch-Index%E5%92%8CType%E7%9A%84%E5%8C%BA%E5%88%AB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>IP命令集</title>
      <link>http://blog.loveops.com/2017/11/22/IP%E5%91%BD%E4%BB%A4%E9%9B%86/</link>
      <guid>http://blog.loveops.com/2017/11/22/IP%E5%91%BD%E4%BB%A4%E9%9B%86/</guid>
      <pubDate>Wed, 22 Nov 2017 03:45:47 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。</p><h4 id="IP查询命令"><a href="#IP查询命令" class="headerlink" title="IP查询命令"></a>IP查询命令</h4><ul><li><p>addr  显示ip地址和属性信息（address的缩写）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip addr  显示所有地址信息</span><br><span class="line"></span><br><span class="line">ip addr show dev eth0  只显示eth0的信息</span><br></pre></td></tr></table></figure></li><li><p>link 管理和显示所有网络接口的状态</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link 显示所有接口的信息</span><br><span class="line"></span><br><span class="line">ip link show dev eth0  只显示eth0的信息</span><br><span class="line"></span><br><span class="line">ip -s link  显示接口统计</span><br></pre></td></tr></table></figure><ul><li>route 显示和修改路由表</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip<span class="built_in"> route </span>列出内核中所有的路由条目</span><br></pre></td></tr></table></figure><ul><li><p>maddr 管理和显示多播地址</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip maddr 显示所有接口的多播地址</span><br><span class="line"></span><br><span class="line">ip maddr show dev eth0  只显示eth0的多播地址</span><br></pre></td></tr></table></figure></li><li><p>neigh 显示邻居对象，也就是ipv4的arp表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip neigh  显示邻居对象</span><br><span class="line"></span><br><span class="line">ip neigh show dev eth0 显示eth0的邻居对象</span><br></pre></td></tr></table></figure></li><li><p>help 显示子命令和字命令参数的帮助信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip help  显示ip子命令和参数的帮助信息</span><br><span class="line"></span><br><span class="line">ip addr help  显示 addr 子命令的帮助信息</span><br><span class="line"></span><br><span class="line">ip link help  显示 link 子命令的帮助信息</span><br><span class="line"></span><br><span class="line">ip neigh help 显示 neigh 子命令的帮助信息</span><br></pre></td></tr></table></figure></li></ul><h4 id="多播地址管理"><a href="#多播地址管理" class="headerlink" title="多播地址管理"></a>多播地址管理</h4><ul><li><p>maddr add 添加静态链路层多播地址</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ip</span> <span class="selector-tag">maddr</span> <span class="selector-tag">add</span> 33<span class="selector-pseudo">:33</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span> <span class="selector-tag">dev</span> <span class="selector-tag">eth0</span></span><br></pre></td></tr></table></figure></li><li><p>maddr del  删除一个多播地址</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ip</span> <span class="selector-tag">maddr</span> <span class="selector-tag">del</span> 33<span class="selector-pseudo">:33</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span> <span class="selector-tag">dev</span> <span class="selector-tag">eth0</span></span><br></pre></td></tr></table></figure><h4 id="修改地址和链接属性"><a href="#修改地址和链接属性" class="headerlink" title="修改地址和链接属性"></a>修改地址和链接属性</h4><ul><li><p>addr add  添加一个地址</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr add <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">24</span> dev eth0   #在eth0上添加<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>掩码<span class="number">24</span>位的地址</span><br></pre></td></tr></table></figure></li><li><p>addr del  删除一个地址</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr del <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">24</span> dev eth0   #从eth0上删除<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>掩码<span class="number">24</span>位的地址</span><br></pre></td></tr></table></figure></li><li><p>link set  修改接口状态</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip link <span class="builtin-name">set</span> eth0 up  #开启eth0</span><br><span class="line"></span><br><span class="line">ip link <span class="builtin-name">set</span> eth0 down #关闭eth0 </span><br><span class="line"></span><br><span class="line">ip link <span class="builtin-name">set</span> eth0 mtu 9000 #设置eth0的mtu为9000</span><br><span class="line"></span><br><span class="line">ip link ser eth0 promisc on #开启eth0的混杂模式</span><br></pre></td></tr></table></figure><h4 id="调整和查看路由表"><a href="#调整和查看路由表" class="headerlink" title="调整和查看路由表"></a>调整和查看路由表</h4><ul><li><p>route add  #添加一条路由表条目</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip<span class="built_in"> route </span><span class="builtin-name">add</span><span class="built_in"> default </span>via 192.168.1.1 dev eth0 #在接口eth0上添加默认网关192.168.1.1</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> route </span><span class="builtin-name">add</span> 192.168.1.0/24 via 192.168.1.1 #为192.168.0.0/24的地址添加默认网关192.168.1.1</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> route </span><span class="builtin-name">add</span> 192.168.1.0/24 dev eth0 #添加访问192.168.1.0/24 可以从eth0接口出去</span><br></pre></td></tr></table></figure></li><li><p>route delete  #删除一条路由条目</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip<span class="built_in"> route </span>delete 192.168.1.0/24 via 192.168.1.1</span><br></pre></td></tr></table></figure></li><li><p>route replace  #替换路由条目，如果没有定义就添加</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip<span class="built_in"> route </span>replace 192.168.1.0/24 dev eth0</span><br></pre></td></tr></table></figure></li><li><p>route get #显示一个地址将要走的路由</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip<span class="built_in"> route </span><span class="builtin-name">get</span> 192.168.1.5  #显示192.168.1.5将走的路由</span><br></pre></td></tr></table></figure></li></ul><h4 id="管理arp表"><a href="#管理arp表" class="headerlink" title="管理arp表"></a>管理arp表</h4><ul><li><p>neigh add #向arp表添加一条arp条目</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ip</span> <span class="selector-tag">neigh</span> <span class="selector-tag">add</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> <span class="selector-tag">lladdr</span> 1<span class="selector-pseudo">:2</span><span class="selector-pseudo">:3</span><span class="selector-pseudo">:4</span><span class="selector-pseudo">:5</span><span class="selector-pseudo">:6</span> <span class="selector-tag">dev</span> <span class="selector-tag">eth0</span></span><br></pre></td></tr></table></figure></li><li><p>neigh del #使arp条目失效</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ip</span> <span class="selector-tag">neigh</span> <span class="selector-tag">del</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> <span class="selector-tag">dev</span> <span class="selector-tag">eth0</span></span><br></pre></td></tr></table></figure></li><li><p>neigh replace #替换arp条目，如果不存在就添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ip</span> <span class="selector-tag">neigh</span> <span class="selector-tag">replace</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> <span class="selector-tag">lladdr</span> 1<span class="selector-pseudo">:2</span><span class="selector-pseudo">:3</span><span class="selector-pseudo">:4</span><span class="selector-pseudo">:5</span><span class="selector-pseudo">:6</span> <span class="selector-tag">dev</span> <span class="selector-tag">eth0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="有用的命令（不一定来自iproute）"><a href="#有用的命令（不一定来自iproute）" class="headerlink" title="有用的命令（不一定来自iproute）"></a>有用的命令（不一定来自iproute）</h4><ul><li><p>arping  #向邻居发送arp请求</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arping</span> <span class="selector-tag">-I</span> <span class="selector-tag">eth0</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> # 通过<span class="selector-tag">eth0</span>向192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span>发送<span class="selector-tag">arp</span>请求</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">arping</span> <span class="selector-tag">-D</span> <span class="selector-tag">-I</span> <span class="selector-tag">eth0</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> #在<span class="selector-tag">eth0</span> 上检查192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span>重复的<span class="selector-tag">mac</span>地址</span><br></pre></td></tr></table></figure></li><li><p>ethtool #查询或控制网络驱动程序和硬件设置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ethtool</span> -g eth0  <span class="comment">#显示eth0的环形缓冲区</span></span><br><span class="line">ethtool -i eth0  <span class="comment">#显示eth0的驱动程序信息</span></span><br><span class="line">ethtool -p eth0  <span class="comment">#通过瞄准识别eth0，通常通过使LED闪烁在网络端口上</span></span><br><span class="line">ethtool -S eth0  <span class="comment">#显示eth0的网络和驱动程序统计信息</span></span><br></pre></td></tr></table></figure></li><li><p>ss 显示套接字统计。以下选项可以组合使用</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss -<span class="keyword">a</span> <span class="comment">#显示所有套接字（不管是否listen）</span></span><br><span class="line">ss -e <span class="comment">#显示套接字的详细信息</span></span><br><span class="line">ss -o <span class="comment">#显示计时器信息</span></span><br><span class="line">ss -n <span class="comment">#不解析地址</span></span><br><span class="line">ss -p <span class="comment">#使用套接字显示进程</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="NETTOOLS与IPROUTE对比"><a href="#NETTOOLS与IPROUTE对比" class="headerlink" title="NETTOOLS与IPROUTE对比"></a>NETTOOLS与IPROUTE对比</h4><table><thead><tr><th>NETTOOLS命令</th><th>IPROUTE命令</th></tr></thead><tbody><tr><td>arp -a</td><td>ip neigh</td></tr><tr><td>arp -v</td><td>ip -s neigh</td></tr><tr><td>arp -s 192.168.1.1 1:2:3:4:5:6</td><td>ip neigh add 192.168.1.1 lladdr 1:2:3:4:5:6 dev eth1</td></tr><tr><td>arp -i eth1 -d 192.168.1.1</td><td>ip neigh del 192.168.1.1 dev eth1</td></tr><tr><td>ifconfig -a</td><td>ip addr</td></tr><tr><td>ifconfig eth0 down</td><td>ip link set eth0 down</td></tr><tr><td>ifconfig eth0 up</td><td>ip link set eth0 up</td></tr><tr><td>ifconfig eth0 192.168.1.1</td><td>ip addr add 192.168.1.1/24 dev eth0</td></tr><tr><td>ifconfig eth0 netmask 255.255.255.0</td><td>ip addr add 192.168.1.1/24 dev eth0</td></tr><tr><td>ifconfig eth0 mtu 9000</td><td>ip link set eth0 mtu 9000</td></tr><tr><td>ifconfig eth0:0 192.168.1.2</td><td>ip addr add 192.168.1.2/24 dev eth0</td></tr><tr><td>netstat</td><td>ss</td></tr><tr><td>netstat -neopa</td><td>ss -neopa</td></tr><tr><td>netstat -g</td><td>ip maddr</td></tr><tr><td>route</td><td>ip route</td></tr><tr><td>route add -net 192.168.1.0 netmask 255.255.255.0 dev eth0</td><td>ip route add 192.168.1.0/24 dev eth0</td></tr><tr><td>route add default gw 192.168.1.1</td><td>ip route add default via 192.168.1.1</td></tr></tbody></table>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2017/11/22/IP%E5%91%BD%E4%BB%A4%E9%9B%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP基准测试工具AB介绍</title>
      <link>http://blog.loveops.com/2016/12/09/HTTP%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7AB%E4%BB%8B%E7%BB%8D/</link>
      <guid>http://blog.loveops.com/2016/12/09/HTTP%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7AB%E4%BB%8B%E7%BB%8D/</guid>
      <pubDate>Fri, 09 Dec 2016 12:59:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;ab是apahce自带的一个http服务器基准测试工具，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ab是apahce自带的一个http服务器基准测试工具，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Usage: ab [options] [http[s]://]hostname[:port]/path</span><br><span class="line">Options are:</span><br><span class="line">    -<span class="ruby">n requests     Number of requests to perform</span></span><br><span class="line"><span class="ruby">    -c concurrency  同时向服务器端发送的请求数目，默认状态下是一次 只执行一个http请求.</span></span><br><span class="line"><span class="ruby">    -t timelimit    设置测试的时间的长短，使用这个选项ab将自动设置测试请求会话数目为<span class="number">50000</span>，然后以你设置的时间为固定周期.默认状态下是没有时限的，也就是直到完成你所设置的请求数目为止.</span></span><br><span class="line"><span class="ruby">    -s timeout      每个请求的超时时间.默认是<span class="number">30</span>秒</span></span><br><span class="line"><span class="ruby">    -b windowsize   发送/接受TCPbuffer的大小，以字节为单位</span></span><br><span class="line"><span class="ruby">    -B address      在向外连接时候绑定的地址</span></span><br><span class="line"><span class="ruby">    -p postfile     POST请求包含的数据文件. 配合-T参数使用</span></span><br><span class="line"><span class="ruby">    -u putfile      PUT请求包含的是数据文件. 配合-T参数使用</span></span><br><span class="line"><span class="ruby">    -T content-type 设置Content-type header信息 用于 POST/PUT请求, 例如</span></span><br><span class="line"><span class="ruby"><span class="string">'application/x-www-form-urlencoded'</span>，默认 <span class="string">'text/plain'</span></span></span><br><span class="line"><span class="ruby">    -v verbosity    设置打印输出级别，数字越大显示信息越详细</span></span><br><span class="line"><span class="ruby">    -w              以HTML格式打印结果</span></span><br><span class="line"><span class="ruby">    -i              使用HEAD代替GET</span></span><br><span class="line"><span class="ruby">    -x attributes   String to insert as table attributes</span></span><br><span class="line"><span class="ruby">    -y attributes   String to insert as tr attributes</span></span><br><span class="line"><span class="ruby">    -z attributes   String to insert as td <span class="keyword">or</span> th attributes</span></span><br><span class="line"><span class="ruby">    -C attribute    添加cookie信息, 比如. <span class="string">'Apache=1234'</span>. (repeatable)</span></span><br><span class="line"><span class="ruby">    -H attribute    增加额外的头部信息, 比如 <span class="string">'Accept-Encoding: gzip'</span></span></span><br><span class="line"><span class="ruby">    -A attribute    向服务器提供基本认证信息, 冒号分割用户名密码</span></span><br><span class="line"><span class="ruby">    -P attribute    向代理服务器提供基本认证信息，冒号分割用户名密码</span></span><br><span class="line"><span class="ruby">    -X <span class="symbol">proxy:</span>port   代理服务器的地址和端口</span></span><br><span class="line"><span class="ruby">    -V              显示版本号并退出</span></span><br><span class="line"><span class="ruby">    -k              使用keep-alive功能</span></span><br><span class="line"><span class="ruby">    -d              输出结果不显示请求时间百分比信息.</span></span><br><span class="line"><span class="ruby">    -S              不显示平均指的标准误差值（也就是[+<span class="regexp">/-sd]）.</span></span></span><br><span class="line"><span class="ruby">    -q              不显示执行超过<span class="number">150</span>个请求进度</span></span><br><span class="line"><span class="ruby">    -l              接受动态相应结果 (对动态页面比较管用)</span></span><br><span class="line"><span class="ruby">    -g filename     将每个请求的时间输出到一个文件中.</span></span><br><span class="line"><span class="ruby">    -e filename     将每个请求的时间输出到一个csv文件中</span></span><br><span class="line"><span class="ruby">    -r              socket错误时不退出</span></span><br><span class="line"><span class="ruby">    -m method       方法名称</span></span><br><span class="line"><span class="ruby">    -h              显示帮助信息</span></span><br><span class="line"><span class="ruby">    -I              Disable TLS Server Name Indication (SNI) extension</span></span><br><span class="line"><span class="ruby">    -Z ciphersuite  Specify SSL/TLS cipher suite (See openssl ciphers)</span></span><br><span class="line"><span class="ruby">    -f protocol     Specify SSL/TLS protocol</span></span><br><span class="line"><span class="ruby">                    (SSL3, TLS1, TLS1.<span class="number">1</span>, TLS1.<span class="number">2</span> <span class="keyword">or</span> ALL)</span></span><br></pre></td></tr></table></figure><h4 id="简单测试结果"><a href="#简单测试结果" class="headerlink" title="简单测试结果"></a>简单测试结果</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">ab</span> <span class="bullet">-c</span> <span class="number">10</span> <span class="bullet">-n</span> <span class="number">100</span> <span class="attr">https://blog.loveops.org/</span></span><br><span class="line"><span class="string">This</span> <span class="string">is</span> <span class="string">ApacheBench,</span> <span class="string">Version</span> <span class="number">2.3</span> <span class="string">&lt;$Revision:</span> <span class="number">1796539</span> <span class="string">$&gt;</span></span><br><span class="line"><span class="string">Copyright</span> <span class="number">1996</span> <span class="string">Adam</span> <span class="string">Twiss,</span> <span class="string">Zeus</span> <span class="string">Technology</span> <span class="string">Ltd,</span> <span class="attr">http://www.zeustech.net/</span></span><br><span class="line"><span class="string">Licensed</span> <span class="string">to</span> <span class="string">The</span> <span class="string">Apache</span> <span class="string">Software</span> <span class="string">Foundation,</span> <span class="attr">http://www.apache.org/</span></span><br><span class="line"></span><br><span class="line"><span class="string">Benchmarking</span> <span class="string">blog.loveops.org</span> <span class="string">(be</span> <span class="string">patient).....done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">Server</span> <span class="attr">Software:</span>        <span class="string">nginx/1.10.3</span></span><br><span class="line"><span class="string">Server</span> <span class="attr">Hostname:</span>        <span class="string">blog.loveops.org</span></span><br><span class="line"><span class="string">Server</span> <span class="attr">Port:</span>            <span class="number">443</span></span><br><span class="line"><span class="string">SSL/TLS</span> <span class="attr">Protocol:</span>       <span class="string">TLSv1.2,ECDHE-RSA-AES256-GCM-SHA384,2048,256</span></span><br><span class="line"><span class="string">TLS</span> <span class="string">Server</span> <span class="attr">Name:</span>        <span class="string">blog.loveops.org</span></span><br><span class="line"></span><br><span class="line"><span class="string">Document</span> <span class="attr">Path:</span>          <span class="string">/</span>     <span class="comment">#请求URI  </span></span><br><span class="line"><span class="string">Document</span> <span class="attr">Length:</span>        <span class="number">57416</span> <span class="string">bytes</span>  <span class="comment">#请求返回文档大小，这个数值如果变化，则被认为是错误</span></span><br><span class="line"></span><br><span class="line"><span class="string">Concurrency</span> <span class="attr">Level:</span>      <span class="number">10</span>  <span class="comment">#并发连接数</span></span><br><span class="line"><span class="string">Time</span> <span class="string">taken</span> <span class="string">for</span> <span class="attr">tests:</span>   <span class="number">21.204</span> <span class="string">seconds</span>  <span class="comment">#测试时间</span></span><br><span class="line"><span class="string">Complete</span> <span class="attr">requests:</span>      <span class="number">100</span> <span class="comment">#完成总请求数</span></span><br><span class="line"><span class="string">Failed</span> <span class="attr">requests:</span>        <span class="number">0</span>   <span class="comment">#失败请求数</span></span><br><span class="line"><span class="string">Total</span> <span class="attr">transferred:</span>      <span class="number">5767500</span> <span class="string">bytes</span> <span class="comment"># 网络传输量</span></span><br><span class="line"><span class="string">HTML</span> <span class="attr">transferred:</span>       <span class="number">5741600</span> <span class="string">bytes</span> <span class="comment"># html传输量</span></span><br><span class="line"><span class="string">Requests</span> <span class="string">per</span> <span class="attr">second:</span>    <span class="number">4.72</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span> <span class="comment">#每秒请求数（平均）</span></span><br><span class="line"><span class="string">Time</span> <span class="string">per</span> <span class="attr">request:</span>       <span class="number">2120.353</span> <span class="string">[ms]</span> <span class="string">(mean)</span> <span class="comment"># （每次请求花费的平均时间）</span></span><br><span class="line"><span class="string">Time</span> <span class="string">per</span> <span class="attr">request:</span>       <span class="number">212.035</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span>     <span class="comment"># 服务器平均请求处理时间</span></span><br><span class="line"><span class="string">Transfer</span> <span class="attr">rate:</span>          <span class="number">265.63</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span> <span class="comment">#平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</span></span><br><span class="line"></span><br><span class="line"><span class="string">Connection</span> <span class="string">Times</span> <span class="string">(ms)</span>   <span class="comment"># 网络上消耗的时间的分解</span></span><br><span class="line">              <span class="string">min</span>  <span class="string">mean[+/-sd]</span> <span class="string">median</span>   <span class="string">max</span></span><br><span class="line"><span class="attr">Connect:</span>      <span class="number">128</span>  <span class="number">910</span> <span class="number">1140.1</span>    <span class="number">588</span>    <span class="number">8981</span></span><br><span class="line"><span class="attr">Processing:</span>   <span class="number">229</span>  <span class="number">993</span> <span class="number">711.6</span>    <span class="number">689</span>    <span class="number">3338</span></span><br><span class="line"><span class="attr">Waiting:</span>       <span class="number">70</span>  <span class="number">435</span> <span class="number">517.5</span>    <span class="number">169</span>    <span class="number">2383</span></span><br><span class="line"><span class="attr">Total:</span>        <span class="number">379</span> <span class="number">1903</span> <span class="number">1268.2</span>   <span class="number">1717</span>   <span class="number">10272</span></span><br><span class="line"></span><br><span class="line"><span class="string">Percentage</span> <span class="string">of</span> <span class="string">the</span> <span class="string">requests</span> <span class="string">served</span> <span class="string">within</span> <span class="string">a</span> <span class="string">certain</span> <span class="string">time</span> <span class="string">(ms)</span> <span class="comment">#每个请求处理时间的分布情况，比如：50%请求处理时间在1717ms内</span></span><br><span class="line">  <span class="number">50</span><span class="string">%</span>   <span class="number">1717</span></span><br><span class="line">  <span class="number">66</span><span class="string">%</span>   <span class="number">2359</span></span><br><span class="line">  <span class="number">75</span><span class="string">%</span>   <span class="number">2667</span></span><br><span class="line">  <span class="number">80</span><span class="string">%</span>   <span class="number">2750</span></span><br><span class="line">  <span class="number">90</span><span class="string">%</span>   <span class="number">3374</span></span><br><span class="line">  <span class="number">95</span><span class="string">%</span>   <span class="number">3534</span></span><br><span class="line">  <span class="number">98</span><span class="string">%</span>   <span class="number">3928</span></span><br><span class="line">  <span class="number">99</span><span class="string">%</span>  <span class="number">10272</span></span><br><span class="line"> <span class="number">100</span><span class="string">%</span>  <span class="number">10272</span> <span class="string">(longest</span> <span class="string">request)</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2016/12/09/HTTP%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7AB%E4%BB%8B%E7%BB%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ES索引设置</title>
      <link>http://blog.loveops.com/2016/11/25/ES%E7%B4%A2%E5%BC%95%E8%AE%BE%E7%BD%AE/</link>
      <guid>http://blog.loveops.com/2016/11/25/ES%E7%B4%A2%E5%BC%95%E8%AE%BE%E7%BD%AE/</guid>
      <pubDate>Fri, 25 Nov 2016 13:20:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;索引级别的设置可以针对每个索引进行单独设置，设置分为两种：&quot;&gt;&lt;a href=&quot;#索引级别的设置可以针对每个索引进行单独设置，设置分为两种：&quot; class=&quot;headerlink&quot; title=&quot;索引级别的设置可以针对每个索引进行单独设置，设置分为两种：&quot;&gt;&lt;/a
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="索引级别的设置可以针对每个索引进行单独设置，设置分为两种："><a href="#索引级别的设置可以针对每个索引进行单独设置，设置分为两种：" class="headerlink" title="索引级别的设置可以针对每个索引进行单独设置，设置分为两种："></a>索引级别的设置可以针对每个索引进行单独设置，设置分为两种：</h3><ul><li>静态设置：只能在索引创建或者状态为关闭的时候设置</li><li>动态设置：可以用 update-index-settings API在索引激活时修改</li></ul><h3 id="静态索引设置："><a href="#静态索引设置：" class="headerlink" title="静态索引设置："></a>静态索引设置：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.number_of_shards：</span><br><span class="line"></span><br><span class="line">索引主分片的数量，模式值是<span class="number">5</span>，这个只能在索引创建时指定，在关闭的索引上无法修改;</span><br><span class="line">注意：分片数量限制为每个索引 <span class="number">1024</span> 个。这是一种安全限制，防止意外创建索引后资源分配导致集群不稳定。可以通过在集群的每个节点上设置环境变量 ES_JAVA_OPTS =<span class="string">"- Des.index.max_number_of_shards = 128"</span> 来修改限制</span><br></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">index</span>.shard.check_on_startup</span><br><span class="line"></span><br><span class="line">是否应在索引打开前检查分片是否损坏，当检查到分片损坏将禁止分片被打开。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">false</span>: 默认值，打开索引时候不检查分片是否损坏</span><br><span class="line"></span><br><span class="line">    checksum：检查物理损坏</span><br><span class="line"></span><br><span class="line">    <span class="keyword">true</span>：检查物理和逻辑损坏，这将消耗大量的内存和cpu</span><br><span class="line"></span><br><span class="line">    fix：检查物理和逻辑损坏。有损坏的分片将被集群自动删除，这将导致数据丢失。该选项也许会造成数据丢失。使用时请考虑清楚。</span><br><span class="line">         检查分片在数据量大的索引会消耗更多的时间。</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index<span class="selector-class">.codec</span>:默认使用LZ4压缩方式存储数据，也可以设置为 best_compression，它使用 DEFLATE 方式以牺牲字段存储性能为代价来获得更高的压缩比例。</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index<span class="selector-class">.routing_partition_size</span>:</span><br><span class="line"></span><br><span class="line">自定义路由值可以转发的目的分片数。默认为 <span class="number">1</span>，只能在索引创建时设置。此值必须小于 index.number_of_shards，除非 index<span class="selector-class">.number_of_shards</span> 值也为 <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="动态索引设置："><a href="#动态索引设置：" class="headerlink" title="动态索引设置："></a>动态索引设置：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.number_of_replicas</span><br><span class="line">     每个主分片的副本数。默认为 <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">index</span>.auto_expand_replicas</span><br><span class="line">      基于可用节点的数量自动分配副本数量。可以设置为以中划线分隔的最小值和最大值（例如 <span class="number">0</span><span class="number">-5</span>）或设置最大值为 <span class="built_in">all</span>（例如<span class="number">0</span>-<span class="built_in">all</span>）。默认为 <span class="literal">false</span>（即禁用此功能）</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.refresh_interval</span><br><span class="line">      执行刷新操作的频率，这使得索引的最近更改可以被搜索。默认为 <span class="number">1</span> 秒。可以设置为 <span class="number">-1</span> 以禁用刷新。</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.max_result_window</span><br><span class="line">      用于索引搜索的 <span class="keyword">from</span>+<span class="keyword">size</span> 的最大值。默认为 <span class="number">10000</span>。搜索请求占用堆内存和时间与 <span class="keyword">from</span>+<span class="keyword">size</span> 的大小成正比，有此限制是为了防止内存溢出。请参阅 Scroll 或 Search After，以提高效率。</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.max_rescore_window</span><br><span class="line">      在搜索此索引中 rescore 的 window_size 的最大值。默认为 <span class="string">"index.max_result_window"</span> 设置的值即 <span class="number">10000</span>。搜索请求占用堆内存和时间与 <span class="keyword">from</span>+<span class="keyword">size</span> 的大小成正比，有此限制是为了防止内存溢出。</span><br></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">index</span>.blocks.read_only</span><br><span class="line">      设置为 <span class="keyword">true</span> 使索引和索引元数据为只读，<span class="keyword">false</span> 为允许写入和元数据更改。</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index<span class="selector-class">.blocks</span><span class="selector-class">.read</span></span><br><span class="line">      设置为 true 可禁用对索引的读取操作。</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index<span class="selector-class">.blocks</span><span class="selector-class">.write</span></span><br><span class="line">      设置为 true 可禁用对索引的写入操作。</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index<span class="selector-class">.blocks</span><span class="selector-class">.metadata</span></span><br><span class="line">      设置为 true 可禁用索引元数据的读取和写入。</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.max_refresh_listeners</span><br><span class="line">      索引的每个分片上可用的最大刷新侦听器数。这些侦听器用于实现 <span class="attribute">refresh</span>=wait_for。</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2016/11/25/ES%E7%B4%A2%E5%BC%95%E8%AE%BE%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mesos+marathon+docker安装文档</title>
      <link>http://blog.loveops.com/2016/11/23/mesos-marathon-docker%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</link>
      <guid>http://blog.loveops.com/2016/11/23/mesos-marathon-docker%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</guid>
      <pubDate>Wed, 23 Nov 2016 13:44:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h4&gt;&lt;p&gt;ubuntu14.04 LTS&lt;/p&gt;
&lt;h4 id=&quot;角色分配&quot;&gt;&lt;a href=&quot;#角色分配&quot; class=&quot;heade
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><p>ubuntu14.04 LTS</p><h4 id="角色分配"><a href="#角色分配" class="headerlink" title="角色分配"></a>角色分配</h4><table><thead><tr><th>IP地址</th><th>主机名</th><th>角色</th></tr></thead><tbody><tr><td>192.168.9.100</td><td>mesos-master01</td><td>mesos-master,marathon,consul,es</td></tr><tr><td>192.168.9.101</td><td>mesos-master02</td><td>mesos-master,marathon,consul,es</td></tr><tr><td>192.168.9.102</td><td>mesos-master03</td><td>mesos-master,marathon,consul,es</td></tr><tr><td>192.168.9.104</td><td>mesos-slave01</td><td>mesos-slave,consul-client,registrator</td></tr><tr><td>192.168.9.105</td><td>mesos-slave02</td><td>mesos-slave,consul-client,registrator</td></tr><tr><td>192.168.9.106</td><td>mesos-slave03</td><td>mesos-slave,consul-client,registrator</td></tr><tr><td>192.168.9.107</td><td>mesos-slave04</td><td>mesos-slave,consul-client,registrator</td></tr></tbody></table><h4 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h4><p>以下操作在所有主机：</p><h4 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h4><p>设置为亚洲上海</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dpkg-reconfigure tzdata</span></span><br></pre></td></tr></table></figure><p>设置时间同步，写入计划任务</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="regexp">/20 * * * * /u</span>sr<span class="regexp">/sbin/</span>ntpdate pool.ntp.org &gt; <span class="regexp">/dev/</span><span class="keyword">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="设置主机名，添加hosts"><a href="#设置主机名，添加hosts" class="headerlink" title="设置主机名，添加hosts"></a>设置主机名，添加hosts</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.9</span><span class="selector-class">.100</span>  <span class="selector-tag">mesos-master01</span>  </span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.9</span><span class="selector-class">.101</span>  <span class="selector-tag">mesos-master02</span>  </span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.9</span><span class="selector-class">.102</span>  <span class="selector-tag">mesos-master03</span>  </span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.9</span><span class="selector-class">.104</span>  <span class="selector-tag">mesos-slave01</span>   </span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.9</span><span class="selector-class">.105</span>  <span class="selector-tag">mesos-slave02</span>   </span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.9</span><span class="selector-class">.106</span>  <span class="selector-tag">mesos-slave03</span>   </span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.9</span><span class="selector-class">.107</span>  <span class="selector-tag">mesos-slave04</span></span><br></pre></td></tr></table></figure><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http<span class="variable">s:</span>//<span class="built_in">get</span>.daocloud.io/docker | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><h4 id="添加mesos源"><a href="#添加mesos源" class="headerlink" title="添加mesos源"></a>添加mesos源</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.<span class="keyword">com</span> --recv E56151BF</span><br><span class="line">DISTRO=$(lsb_release -<span class="keyword">is</span> | <span class="keyword">tr</span> <span class="string">'[:upper:]'</span> <span class="string">'[:lower:]'</span>)</span><br><span class="line">CODENAME=$(lsb_release -<span class="keyword">cs</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"deb http://repos.mesosphere.io/$&#123;DISTRO&#125; $&#123;CODENAME&#125; main"</span> | sudo tee /etc/apt/sources.<span class="keyword">list</span>.d/mesosphere.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><h4 id="更新apt源"><a href="#更新apt源" class="headerlink" title="更新apt源"></a>更新apt源</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><h4 id="安装mesos"><a href="#安装mesos" class="headerlink" title="安装mesos"></a>安装mesos</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install mesos</span><br></pre></td></tr></table></figure><p>配置文件一般为：</p><ul><li>全局配置文件目录：/etc/mesos</li><li>master配置文件目录：/etc/mesos-master</li><li>slave配置文件目录：/etc/mesos-slave</li></ul><p>为了使master正常工作，有三个必须配置的变量：</p><ul><li>ZooKeeper URL（zk）</li><li>quorum</li><li>work_dir</li></ul><p>如需添加其他配置可以相应目录下创建相应文件夹<br>比如：cluster   内容写集群名字，<br>leader如果不跳转 需要在此目录配置 hostname</p><h4 id="配置mesos-master"><a href="#配置mesos-master" class="headerlink" title="配置mesos-master"></a>配置mesos-master</h4><p>以下只需要在9.100-102三台设置即可，ip地址修改为相应的ip地址</p><p>这里使用线上的zk集群<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "zk://<span class="number">192.168.9.21</span>:<span class="number">2181,192.168</span>.<span class="number">9.22:2181</span>,<span class="number">192.168.9.25</span>:<span class="number">2181</span>/mesos" &gt; /etc/mesos/zk</span><br></pre></td></tr></table></figure></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"192.168.9.101"</span> &gt; <span class="string">/etc/mesos-master/hostname</span></span><br></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"prod"</span> &gt; <span class="string">/etc/mesos-master/cluster</span></span><br></pre></td></tr></table></figure><h4 id="启动mesos-master"><a href="#启动mesos-master" class="headerlink" title="启动mesos-master"></a>启动mesos-master</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mesos-<span class="keyword">master</span> <span class="title">start</span></span><br></pre></td></tr></table></figure><h4 id="配置mesos-slave"><a href="#配置mesos-slave" class="headerlink" title="配置mesos-slave"></a>配置mesos-slave</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "zk://<span class="number">192.168.9.21</span>:<span class="number">2181,192.168</span>.<span class="number">9.22:2181</span>,<span class="number">192.168.9.25</span>:<span class="number">2181</span>/mesos" &gt; /etc/mesos/zk</span><br></pre></td></tr></table></figure><h4 id="配置memsos-slave支持docker"><a href="#配置memsos-slave支持docker" class="headerlink" title="配置memsos-slave支持docker"></a>配置memsos-slave支持docker</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'docker,mesos'</span> &gt; <span class="regexp">/etc/m</span>esos-slave<span class="regexp">/containerizers</span></span><br></pre></td></tr></table></figure><h4 id="增加执行器超时时间，为了拉取镜像的时间"><a href="#增加执行器超时时间，为了拉取镜像的时间" class="headerlink" title="增加执行器超时时间，为了拉取镜像的时间"></a>增加执行器超时时间，为了拉取镜像的时间</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'10mins'</span> &gt; <span class="regexp">/etc/m</span>esos-slave<span class="regexp">/executor_registration_timeout</span></span><br></pre></td></tr></table></figure><h4 id="安装marathon"><a href="#安装marathon" class="headerlink" title="安装marathon"></a>安装marathon</h4><p>marathon新版本需要java1.8支持，先安装java</p><p>添加ppa安装java</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add</span>-apt-repository <span class="keyword">pp</span><span class="variable">a:webupd8team</span>/java</span><br><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="built_in">get</span> install oracle-java8-installer</span><br></pre></td></tr></table></figure><p>设置java1.8位默认java环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> <span class="keyword">oracle</span>-java8-<span class="keyword">set</span>-<span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>安装marathon</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install marathon</span><br></pre></td></tr></table></figure><p>启动marathon</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">service</span> <span class="keyword">marathon </span>start</span><br></pre></td></tr></table></figure><h4 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h4><p>下载consul二进制文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>releases.hashicorp.com<span class="regexp">/consul/</span><span class="number">0.7</span>.<span class="number">2</span><span class="regexp">/consul_0.7.2_linux_amd64.zip</span></span><br></pre></td></tr></table></figure><p>解压文件，然后分发到每台机器上。</p><p>9.100-9.102 三台服务器启动server角色</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect <span class="number">3</span> -data-dir /data/consul  -dc=prod -bind=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> -client=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> -advertise=<span class="number">192.168</span><span class="number">.9</span><span class="number">.100</span> -ui</span><br></pre></td></tr></table></figure><p>192.104-9.107 4台服务器上启动client角色</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -data-dir /data/consul -bind=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> -client=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> -dc=<span class="number">51</span>idc-prod -advertise=<span class="number">192.168</span><span class="number">.9</span><span class="number">.104</span> -join <span class="number">192.168</span><span class="number">.9</span><span class="number">.100</span></span><br></pre></td></tr></table></figure><h4 id="启动registrator-容器"><a href="#启动registrator-容器" class="headerlink" title="启动registrator 容器"></a>启动registrator 容器</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -it <span class="params">--name</span> registrator <span class="params">--restart</span> always <span class="params">--volume</span> <span class="string">/var/run/docker.sock</span>:<span class="string">/tmp/docker.sock</span> gliderlabs/registrator -resync 60 -ip 192.168.9.105 consul:<span class="string">//192.168.9.105</span><span class="function">:8500</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2016/11/23/mesos-marathon-docker%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Rsyslog-v8学习笔记七(RainerScript)</title>
      <link>http://blog.loveops.com/2016/10/07/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-RainerScript/</link>
      <guid>http://blog.loveops.com/2016/10/07/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-RainerScript/</guid>
      <pubDate>Fri, 07 Oct 2016 09:04:21 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;RainerScript&quot;&gt;&lt;a href=&quot;#RainerScript&quot; class=&quot;headerlink&quot; title=&quot;RainerScript&quot;&gt;&lt;/a&gt;RainerScript&lt;/h3&gt;&lt;p&gt;RainerScript是一种特别设计的脚本语言，非常适合处
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="RainerScript"><a href="#RainerScript" class="headerlink" title="RainerScript"></a>RainerScript</h3><p>RainerScript是一种特别设计的脚本语言，非常适合处理网络事件和配置事件处理器。 它是用于rsyslog的主要配置语言。 请注意，RainerScript可能不会被当作rscript，因为这是别人的商标。<br>从rsyslog 3.12.0开始，开始慢慢支持RainerScript（支持expression），<br> 在第5版中，支持“if … then”语句。 从rsyslog v6开始，基本达到全部支持。</p><h4 id="Data-Types-（数据类型）"><a href="#Data-Types-（数据类型）" class="headerlink" title="Data Types （数据类型）"></a>Data Types （数据类型）</h4><p>RainerScript是一种无类型的语言。 这并不意味着你不需要关心类型。 当然，像“A”+“B”这样的表达式不会返回一个有效的结果，因为你不能真的添加两个字母（连接它们，使用连接运算符＆）。 但是，所有类型的转换都是由脚本解释器在需要时自动完成的。</p><h4 id="Expressions-（表达式）"><a href="#Expressions-（表达式）" class="headerlink" title="Expressions （表达式）"></a>Expressions （表达式）</h4><p>该语言支持任意复杂的表达式。 所有常用的操作符都支持。 操作的优先级如下（列表中较低的操作在列表中较高，例如在添加之前进行乘法。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">expressions <span class="keyword">in</span> parenthesis</span><br><span class="line"><span class="keyword">not</span>, unary minus</span><br><span class="line">*, /, % (modulus, <span class="keyword">as</span> <span class="keyword">in</span> C)</span><br><span class="line">+, -, &amp; (<span class="built_in">string</span> concatenation)</span><br><span class="line">==, !=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=, <span class="keyword">contains</span> (strings!), startswith (strings!)</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br></pre></td></tr></table></figure><p>例如, “not a == b” 返回的不是你想药的结果. 脚本处理器首先处理“not a” 并把返回的布尔值和b比较. 你需要的可能 “not (a == b)”. 你只是想测试两个值是否相等 , 建议用 “!=” 或者 “&lt;&gt;”. 两个效果相等，用哪个根据自己的喜好，所有测试a和b是否相等，应该用“a &lt;&gt; b”.  “not” 运算符在比较表达式中也可以形成复杂的布尔表达式， 在这种情况下，最好用括号。</p><h4 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h4><ul><li>getenv(str)</li></ul><p>像OS调用一样，返回环境变量的值（如果存在）。 如果不存在，则返回空字符串。<br>以下示例可用于基于某个环境变量构建动态过滤器：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> $msg contains getenv(<span class="string">'TRIGGERVAR'</span>) <span class="keyword">then</span> /path/<span class="keyword">to</span>/errfile</span><br></pre></td></tr></table></figure><ul><li>strlen(str)</li></ul><p>返回提供字符串长度</p><ul><li>tolower(str)</li></ul><p>将提供的字符串转换为小写</p><ul><li>cstr(expr)</li></ul><p>将expr转换为字符串值</p><ul><li>cnum(expr)</li></ul><p>将expr转换为数字（整数）注：如果表达式不包含数值，则行为是未定义的。</p><ul><li>wrap(str, wrapper_str)</li></ul><p>返回由wrapper_str包装的str。 例如。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">wrap</span><span class="params">(<span class="string">"foo bar"</span>, <span class="string">"##"</span>)</span></span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"#<span class="subst">#foo</span> bar##"</span></span><br></pre></td></tr></table></figure><ul><li>wrap(str, wrapper_str, escaper_str)<br>返回由wrapper_str包装的str。 但是另外，任何出现在str中的wrapper_str都将被escaper_str替换。 例如。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">wrap</span><span class="params">(<span class="string">"foo'bar"</span>, <span class="string">"'"</span>, <span class="string">"_"</span>)</span></span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"'foo_bar'"</span></span><br></pre></td></tr></table></figure><ul><li>replace(str, substr_to_replace, replace_with)<br>将所有substr_to_replace实例替换为replace_with的新字符串。 例如。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">replace</span><span class="params">(<span class="string">"foo bar baz"</span>, <span class="string">" b"</span>, <span class="string">", B"</span>)</span></span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"foo, Bar, Baz"</span></span><br></pre></td></tr></table></figure><ul><li>re_match(expr, re)</li></ul><p>返回1，如果expr匹配re，否则返回0。 使用POSIX ERE。</p><ul><li>re_extract(expr, re, match, submatch, no-found)</li></ul><p>通过正则表达式匹配从字符串（属性）提取数据。 使用POSIX ERE正则表达式。 变量“match”包含要使用的匹配的编号。 这允许拾取比第一个表达式匹配更多。 Submatch是匹配的子匹配（最多支持50个）。 “no-found”参数指定在找不到正则表达式的情况下要返回哪个字符串。 请注意，匹配和子匹配从零开始。 目前不可能通过一次调用提取多个子匹配。</p><ul><li>field(str, delim, matchnbr)</li></ul><p>返回一个基于字段的子字符串。 str是要搜索的字符串，delim是分隔符，matchnbr是搜索的匹配（第一个匹配从1开始）。 这与基于字段的属性替换选项类似。 7.3.7之前的版本只支持单个字符作为分隔符。 从版本7.3.7开始，可以使用完整的字符串作为分隔符。 如果使用单个字符作为分隔符，则delim是字段分隔符的数字ascii值（以便可以指定不可打印的字符）。 如果使用字符串作为分隔符，则要指定多字符字符串（例如“＃011”）。</p><p>请注意，当单个字符被指定为字符串字段（$ msg，“，”，3）时，将执行基于字符串的提取，这比等效的单字符字段（$ msg，44,3）提取性能更强。 例如。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> $!usr!<span class="keyword">field</span> = <span class="keyword">field</span>($msg, <span class="number">32</span>, <span class="number">3</span>);  <span class="comment">-- 第三个字段，由空格分开</span></span><br><span class="line"><span class="keyword">set</span> $!usr!<span class="keyword">field</span> = <span class="keyword">field</span>($msg, <span class="string">"#011"</span>, <span class="number">2</span>); <span class="comment">-- 第二个字段，有 "#011"分开</span></span><br></pre></td></tr></table></figure><ul><li>exec_template</li></ul><p>通过执行模板设置变量。 基本上，这可以很容易地提取属性的一些部分，并在以后使用它作为任何其他变量。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template(<span class="attribute">name</span>=<span class="string">"extract"</span> <span class="attribute">type</span>=<span class="string">"string"</span> <span class="attribute">string</span>=<span class="string">"%msg:F:5%"</span>)</span><br><span class="line"><span class="builtin-name">set</span> $!xyz = exec_template(<span class="string">"extract"</span>);</span><br></pre></td></tr></table></figure><p>变量xyz 可以用于过滤中 :</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> $!xyz contains <span class="string">'abc'</span> <span class="keyword">then</span> &#123;action()&#125;</span><br></pre></td></tr></table></figure><p>或者创建动态的文件路径 :</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template(<span class="attribute">name</span>=<span class="string">"DynaFile"</span> <span class="attribute">type</span>=<span class="string">"string"</span> <span class="attribute">string</span>=<span class="string">"/var/log/%$!xyz%-data/%timereported%-%$!xyz%.log"</span>)</span><br></pre></td></tr></table></figure><p>更多信息请参考: <a href="http://www.rsyslog.com/how-to-use-set-variable-and-exec_template" target="_blank" rel="noopener">http://www.rsyslog.com/how-to-use-set-variable-and-exec_template</a></p><ul><li>prifilt(constant)</li></ul><p>模仿传统的基于PRI的过滤器（如“<em>.</em>”或“mail.info”）。 传统的过滤器字符串必须以常量字符串形式给出。 动态字符串评估是不允许的（出于性能原因）。</p><ul><li>dyn_inc(bucket_name_literal_string, str)</li></ul><p>递增在由bucket_name_literal_string标识的dyn-stats存储区中由str标识的计数器。 增量成功时返回0，任何其他返回值都表示增量失败。<br>这里更新的计数器是由impstats报告的。<br>除特殊情况（如内存分配失败等）外，由于度量标准基数被低估，递增可能失败。 Bucket被配置为支持最大基数（以防止滥用），并且在满时遇到新的（以前未见过的）度量名称（str）时拒绝增量操作。</p><p>在这里了解更多关于它的动态统计:<a href="http://www.rsyslog.com/doc/v8-stable/configuration/dyn_stats.html" target="_blank" rel="noopener">http://www.rsyslog.com/doc/v8-stable/configuration/dyn_stats.html</a></p><ul><li>lookup(table_name_literal_string, key)</li></ul><p>查找表是一个强大的构造，可以根据消息内容获取类信息。 它在一个数据文件的顶部工作，该数据文件将键（要查找）映射到值（查找的结果）。<br>这个想法是使用消息属性（或它的衍生物）作为索引到表中，然后返回另一个值。 例如，$ fromhost-ip可以用作索引，表值代表服务器的类型或者它所在的部门或远程办公室。</p><p>在这里阅读更多关于它查找表:<a href="http://www.rsyslog.com/doc/v8-stable/configuration/lookup_tables.html" target="_blank" rel="noopener">http://www.rsyslog.com/doc/v8-stable/configuration/lookup_tables.html</a></p><ul><li>num2ipv4</li></ul><p>将整数转换为IPv4地址并以字符串形式返回地址。 输入是一个值在0到4294967295之间的整数。输出格式是’&gt;十进制&lt;.&gt;十进制&lt;.&gt;十进制&lt;.&gt;十进制&lt;’和’-1’，如果整数输入无效或函数遇到 问题。</p><ul><li>ipv42num</li></ul><p>将IPv4地址转换为整数并返回整数。 输入是一个字符串; 期望的地址格式可能包括开始和结束的空格，但是不能包含任何其他的字符（除了点）。 如果格式确实包含这些，则该函数将导致错误并返回-1。</p><ul><li>ltrim</li></ul><p>删除给定字符串开始处的任何空格。 输入是一个字符串，输出是从第一个非空格字符开始的相同字符串。</p><ul><li>rtrim</li></ul><p>删除给定字符串末尾的空格。 输入是一个字符串，输出是以最后一个非空格字符结尾的相同字符串。</p><p>format_time(unix_timestamp, format_str）</p><p>注意：这是实验性的代码 - 它可能会在8.30.0以后的版本中被删除或更改。 请密切关注ChangeLog的更新。</p><p>将UNIX时间戳转换为格式化的RFC 3164或RFC 3339日期/时间字符串。 第一个参数应该是一个整数值，表示1970-01-01T00：00：0Z（UNIX时代）以来的秒数。 第二个参数可以是“date-rfc3164”或“date-rfc3339”之一。 输出是一个包含格式化日期/时间的字符串。 日期/时间字符串以UTC表示（不提供时区转换）。</p><p>注意：如果函数的输入不是合适的UNIX时间戳，则将返回包含参数原始值的字符串，而不是格式化的日期/时间字符串。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">format_time</span><span class="params">(<span class="number">1507165811</span>, <span class="string">"date-rfc3164"</span>)</span></span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Oct</span>  5 01<span class="selector-pseudo">:10</span><span class="selector-pseudo">:11</span></span><br></pre></td></tr></table></figure><p>另一个</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">format_time</span><span class="params">(<span class="number">1507165811</span>, <span class="string">"date-rfc3339"</span>)</span></span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-10-05T01</span><span class="selector-pseudo">:10</span><span class="selector-pseudo">:11Z</span></span><br></pre></td></tr></table></figure><p>在UNIX时间戳无效的情况下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">format_time</span><span class="params">(<span class="string">"foo"</span>, <span class="string">"date-rfc3339"</span>)</span></span></span><br></pre></td></tr></table></figure><p>产生原始值:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">foo</span></span><br></pre></td></tr></table></figure><ul><li>parse_time(timestamp)</li></ul><p>将RFC 3164或RFC 3339格式的日期/时间字符串转换为UNIX时间戳（表示自UNIX时代以来秒数的整数值：1970-01-01T00：00：0Z）。</p><p>如果函数的输入不是格式正确的RFC 3164或RFC 3339日期/时间字符串，或者无法解析，则返回0。</p><p>注意：此功能不支持包含年份或时区信息的特殊RFC 3164日期/时间。<br>注意：RFC 3339日期/时间字符串中的小数秒（如果存在）将被丢弃。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_time(<span class="string">"Oct  5 01:10:11"</span>) # Assumes the current year (<span class="number">2017</span>, <span class="keyword">in</span> <span class="keyword">this</span> example)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1507165811</span></span><br></pre></td></tr></table></figure><p>另一种</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">parse_time</span><span class="params">(<span class="string">"2017-10-05T01:10:11+04:00"</span>)</span></span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1507151411</span></span><br></pre></td></tr></table></figure><h4 id="Control-Structures-（控制结构）"><a href="#Control-Structures-（控制结构）" class="headerlink" title="Control Structures （控制结构）"></a>Control Structures （控制结构）</h4><p>RainerScript中的控制结构与C，Java，Javascript，Ruby，Bash等许多其他主流语言的语义类似。因此本节假定读者熟悉这样的结构的语义，并且在使用中描述RainerScript实现 例子形式而不是形式定义和详细的语义文档。</p><p>RainerScript支持以下控制结构：</p><ul><li>if</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="symbol">$</span>msg contains <span class="string">"important"</span>) <span class="keyword">then</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( <span class="symbol">$</span>.foo != <span class="string">""</span> ) <span class="keyword">then</span> <span class="keyword">set</span> $.foo <span class="comment">= $.bar &amp; $.baz</span>;</span><br><span class="line">   action(type=<span class="string">"omfile"</span> <span class="keyword">file</span>=<span class="string">"/var/log/important.log"</span> template=<span class="string">"outfmt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if/else-if/else</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$msg</span> contains <span class="string">"important"</span>) then &#123;</span><br><span class="line">   <span class="builtin-name">set</span> $.foo = $.bar &amp; $.baz;</span><br><span class="line">   action(<span class="attribute">type</span>=<span class="string">"omfile"</span> <span class="attribute">file</span>=<span class="string">"/var/log/important.log"</span> <span class="attribute">template</span>=<span class="string">"outfmt"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$msg</span> startswith <span class="string">"slow-query:"</span>) then &#123;</span><br><span class="line">   action(<span class="attribute">type</span>=<span class="string">"omfile"</span> <span class="attribute">file</span>=<span class="string">"/var/log/slow_log.log"</span> <span class="attribute">template</span>=<span class="string">"outfmt"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="builtin-name">set</span> $.foo = $.quux;</span><br><span class="line">   action(<span class="attribute">type</span>=<span class="string">"omfile"</span> <span class="attribute">file</span>=<span class="string">"/var/log/general.log"</span> <span class="attribute">template</span>=<span class="string">"outfmt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>foreach<br>Foreach可以迭代数组和对象。 与数组迭代（有序）相反，对象迭代以任意顺序（无序）访问键值。</li></ul><p>对于下面的foreach调用：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach (<span class="variable">$.</span>i <span class="keyword">in</span> <span class="variable">$.</span>collection) <span class="keyword">do</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意识是 $.collection 是个数组 [1, “2”, {“a”: “b”}, 4], 指 $.i 将循环调用 1, “2”, {“a” : “b”} 和4.</p><p>当$ .collection包含一个对象{“a”：“b”，“c”：[1，2，3]，“d”：{“foo”：“bar”}} 结果将是$.i循环调用{“key”：“a”，“value”：“b”}，{“key”：“c”，“value”：[1，2，3]}和{“key”：“d” ，“value”：{“foo”：“bar”}}（不一定按顺序）。 在这种情况下，键和值将分别作为$.i!key和$.i!value进行访问。</p><p>这里是一个嵌套的foreach语句的例子：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foreach ($.quux <span class="keyword">in</span> $!foo) <span class="keyword">do</span> &#123;</span><br><span class="line">   action(type=<span class="string">"omfile"</span> <span class="keyword">file</span>=<span class="string">"./rsyslog.out.log"</span> template=<span class="string">"quux"</span>)</span><br><span class="line">   foreach ($.corge <span class="keyword">in</span> $.quux!bar) <span class="keyword">do</span> &#123;</span><br><span class="line">      reset $.grault = $.corge;</span><br><span class="line">      action(type=<span class="string">"omfile"</span> <span class="keyword">file</span>=<span class="string">"./rsyslog.out.log"</span> template=<span class="string">"grault"</span>)</span><br><span class="line">      <span class="keyword">if</span> ($.garply != <span class="string">""</span>) then</span><br><span class="line">          set $.garply = $.garply &amp; <span class="string">", "</span>;</span><br><span class="line">      reset $.garply = $.garply &amp; $.grault!baz;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在foreach-statement主体中的异步操作调用几乎总是将action.copyMsg设置为on。 这是因为在foreach中的动作调用通常要使用变量循环填充（在上面的例子中，$ .quux和$ .corge），这会导致消息变异，而异步动作必须看到消息，因为它是在 循环体，所以他们必须做一个副本，以保持安全的进一步修改随着迭代继续。 例如，使用基于链接列表的队列的异步操作调用将如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($.quux <span class="keyword">in</span> $!foo) <span class="keyword">do</span> &#123;</span><br><span class="line">   action(<span class="attribute">type</span>=<span class="string">"omfile"</span> <span class="attribute">file</span>=<span class="string">"./rsyslog.out.log"</span> <span class="attribute">template</span>=<span class="string">"quux"</span> queue.<span class="attribute">type</span>=<span class="string">"linkedlist"</span> action.<span class="attribute">copyMsg</span>=<span class="string">"on"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>call</li></ul><p>细节请参考：<a href="http://www.rsyslog.com/doc/v8-stable/rainerscript/rainerscript_call.html" target="_blank" rel="noopener">http://www.rsyslog.com/doc/v8-stable/rainerscript/rainerscript_call.html</a></p><ul><li>continue</li></ul><p>一个NOP，很有用 例如 if语句中的一部分</p><h4 id="configuration-objects"><a href="#configuration-objects" class="headerlink" title="configuration objects"></a>configuration objects</h4><ul><li>action()</li></ul><p>动作对象是描述要执行的动作的主要手段。</p><ul><li>global()</li></ul><p>这用于设置全局配置参数。 有关详细信息，请参阅rsyslog全局配置对象</p><ul><li>input()</li></ul><p>输入对象是描述输入的主要手段，用于收集rsyslog处理的消息。</p><ul><li>module()</li></ul><p>模块对象用于加载插件。</p><ul><li>parser()</li></ul><p>解析器对象用于定义自定义解析器对象。</p><ul><li>timezone()</li></ul><p>时区对象用于定义时区设置。</p><h4 id="Constant-Strings"><a href="#Constant-Strings" class="headerlink" title="Constant Strings"></a>Constant Strings</h4><p>字符串常量在很多地方都是必需的：比较，配置参数值和函数参数，这里列出几个重要的参数。</p><p>在常量字符串中，特殊字符是通过在它们前面加上反斜杠来进行转义的 - 就像在C编程语言或PHP中一样。</p><p>如果不确定如何正确转义，请使用RainerScript字符串转义在线工具。</p><h4 id="Variable-Property-types-变量（属性）类型"><a href="#Variable-Property-types-变量（属性）类型" class="headerlink" title="Variable (Property) types    变量（属性）类型"></a>Variable (Property) types    变量（属性）类型</h4><p>所有的rsyslog属性（参见列表的属性页面）都可以在RainerScript中使用，前缀为“$”，例如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> $.x！host <span class="comment">= $ hostname</span>;</span><br></pre></td></tr></table></figure><p>另外，它也支持局部变量。局部变量是当前消息的本地变量，但不是消息属性（例如，“$！”，所有的JSON属性都不包含它们）。</p><p>只有消息JSON（CEE /Lumberjack）属性可以通过set，unset和reset语句来修改，而不是任何其他的消息属性。显然，局部变量也是可以修改的。</p><p>消息JSON属性名称以“$！”开头，其中bang字符表示根。</p><p>局部变量名称以“$.”开头，其中点表示根。</p><p>JSON属性和局部变量都可以在最后一个元素之前包含任意的深度路径。爆炸字符总是用作路径分隔符，不管它是一个消息属性还是一个局部变量。例如，“$！path1！path2！varname”是一个三层深度的消息属性，其中非常相似的“$ .path1！path2！varname”指定了一个三层深的局部变量。 rsyslog使用紧跟在美元符号后面的重音符或点符号来分隔不同的类型。</p><p>请注意，后缀分号需要指示表达式的结尾。如果没有给出，配置加载将失败并出现语法错误消息。</p><p>检查以下用法示例以了解这些语句的行为：</p><ul><li>set </li></ul><p>设置局部变量或json属性的值，但是如果被寻址的变量已经包含一个值，它的行为就会有所不同，如下所示：</p><p>如果现有值和新值都是对象，则合并值，但将新值合并到根，而不是与给定键的值合并。 例如。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> $.x!one = <span class="string">"val_1"</span>;</span><br><span class="line"># results <span class="keyword">in</span> $. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125; &#125;</span><br><span class="line"><span class="keyword">set</span> $.y!two = <span class="string">"val_2"</span>;</span><br><span class="line"># results <span class="keyword">in</span> $. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125;, <span class="string">"y"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> $.z!<span class="keyword">var</span> = $.x;</span><br><span class="line"># results <span class="keyword">in</span> $. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125;, <span class="string">"y"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125;, <span class="string">"z"</span>: &#123; <span class="string">"var"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> $.z!<span class="keyword">var</span> = $.y;</span><br><span class="line"># results <span class="keyword">in</span> $. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125;, <span class="string">"y"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125;, <span class="string">"z"</span>: &#123; <span class="string">"var"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125; &#125;, <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125;</span><br><span class="line"># note that the key *two* is at root level and not  under *$.z!<span class="keyword">var</span>*.</span><br></pre></td></tr></table></figure><p>忽略新值如果旧值是一个对象，但新值不是一个对象（如字符串，数字等）。 例如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> $.x!one <span class="comment">=</span> <span class="comment">"val_1"</span>;</span><br><span class="line"><span class="keyword">set</span> $.x <span class="comment">=</span> <span class="comment">"quux"</span>;</span><br><span class="line"># results in <span class="symbol">$</span>. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125; &#125;</span><br><span class="line"># note that <span class="string">"quux"</span> was ignored</span><br></pre></td></tr></table></figure><p>重置变量，如果旧值不是一个对象</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> $.x!val <span class="comment">=</span> <span class="comment">"val_1"</span>;</span><br><span class="line"><span class="keyword">set</span> $.x!val <span class="comment">=</span> <span class="comment">"quux"</span>;</span><br><span class="line"># results in <span class="symbol">$</span>. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"val"</span>: <span class="string">"quux"</span> &#125; &#125;</span><br></pre></td></tr></table></figure><ul><li>unset</li></ul><p>删除变量值. Eg:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> $.x!val <span class="comment">=</span> <span class="comment">"val_1"</span>;</span><br><span class="line">unset <span class="symbol">$</span>.x!val;</span><br><span class="line"># results in <span class="symbol">$</span>. = &#123; <span class="string">"x"</span>: &#123; &#125; &#125;</span><br></pre></td></tr></table></figure><ul><li>reset</li></ul><p>强制设置新的值，而不管最初包含的变量或甚至设置的变量。 例如。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># to contrast with the <span class="keyword">set</span> example above, here is how results would look with reset</span><br><span class="line"><span class="keyword">set</span> $.x!<span class="keyword">one</span> = <span class="string">"val_1"</span>;</span><br><span class="line"><span class="keyword">set</span> $.y!<span class="keyword">two</span> = <span class="string">"val_2"</span>;</span><br><span class="line"><span class="keyword">set</span> $.z!<span class="keyword">var</span> = $.x;</span><br><span class="line"># results <span class="keyword">in</span> $. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125;, <span class="string">"y"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125;, <span class="string">"z"</span>: &#123; <span class="string">"var"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125; &#125; &#125;</span><br><span class="line"># '<span class="keyword">set</span>' or 'reset' can be used interchangeably above(3 lines), they both have the same behaviour, <span class="keyword">as</span> variable doesn't have <span class="keyword">an</span> existing value</span><br><span class="line"></span><br><span class="line">reset $.z!<span class="keyword">var</span> = $.y;</span><br><span class="line"># results <span class="keyword">in</span> $. = &#123; <span class="string">"x"</span>: &#123; <span class="string">"one"</span>: <span class="string">"val_1"</span> &#125;, <span class="string">"y"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125;, <span class="string">"z"</span>: &#123; <span class="string">"var"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125; &#125; &#125;</span><br><span class="line"># <span class="keyword">note</span> how the value of $.z!<span class="keyword">var</span> was replaced</span><br><span class="line"></span><br><span class="line">reset $.x = <span class="string">"quux"</span>;</span><br><span class="line"># results <span class="keyword">in</span> $. = &#123; <span class="string">"x"</span>: <span class="string">"quux"</span>, <span class="string">"y"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125;, <span class="string">"z"</span>: &#123; <span class="string">"var"</span>: &#123; <span class="string">"two"</span>: <span class="string">"val_2"</span> &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><h4 id="Lookup-Tables"><a href="#Lookup-Tables" class="headerlink" title="Lookup Tables"></a>Lookup Tables</h4><p>查找表（<a href="http://www.rsyslog.com/doc/v8-stable/configuration/lookup_tables.html）" target="_blank" rel="noopener">http://www.rsyslog.com/doc/v8-stable/configuration/lookup_tables.html）</a> 是一种功能强大的结构，用于根据消息内容获取“class”信息（例如，为不同的服务器类型，部门或远程办公室构建日志文件名称）。</p><h4 id="General-Queue-Parameters"><a href="#General-Queue-Parameters" class="headerlink" title="General Queue Parameters"></a>General Queue Parameters</h4><p>队列参数可以和下面的语句一起使用：</p><ol><li>action()</li><li>ruleset()</li><li>main_queue()</li></ol><p>队列需要在应该影响的动作或规则集中进行配置。如果没有配置，将使用默认值。因此，默认的规则集只有默认的主队列。 “特定操作”队列默认不设置。要充分了解队列参数及其交互方式，请务必阅读队列文档。<a href="http://www.rsyslog.com/doc/v8-stable/concepts/queues.html" target="_blank" rel="noopener">http://www.rsyslog.com/doc/v8-stable/concepts/queues.html</a></p><ul><li>queue.filename name</li></ul><p>要用于队列文件的文件名。请注意，这实际上只是文件名。不能在此参数中指定一个目录。如果文件应在特定的目录中创建，请为此指定queue.spoolDirectory。<br>文件名用于构建队列文件以完成路径。</p><ul><li>queue.spoolDirectory  name</li></ul><p>名称这是存储队列文件的目录。请注意，该目录必须存在，它不是由rsyslog自动创建的。如果没有指定spoolDirectory，则使用工作目录</p><ul><li>queue.size number</li></ul><p>这是消息数量中队列的最大大小。请注意，将队列大小设置为非常小的值（大约低于100个消息）不受支持，并可能导致不可预知的结果。有关此限制的当前状态的更多信息，请参阅rsyslog FAQ：“队列大小的下限”。默认取决于队列类型和rsyslog版本，如果你需要一个特定的值，请指定它。否则，rsyslog会选择它考虑的版本。例如，在rsyslog rsyslog 8.30.0中，规则集队列的缺省大小为50000，配置为非直接的动作队列的大小为1000。</p><ul><li>queue.dequeuebatchsize number   </li></ul><p>默认128</p><ul><li>queue.maxdiskspace number</li></ul><p>所有队列文件一起在磁盘上使用的最大大小。 请注意，实际大小可能会稍大于配置的最大值，因为rsyslog从不写入部分队列记录。</p><ul><li>queue.highwatermark number</li></ul><p>这仅适用于磁盘辅助队列。 当队列填满这个数量的消息时，队列开始将消息假脱机到磁盘。 请注意，这不应该作为正常处理的一部分发生，因为磁盘队列模式比内存中队列模式慢得多。 对于输出操作目标在一段时间内脱机的情况，应该保留磁盘。 默认90％的队列大小</p><ul><li>queue.lowwatermark number  </li></ul><p>默认70％的队列大小</p><ul><li>queue.fulldelaymark number</li></ul><p>队列应阻塞可延迟消息的消息数。 消息不再处理，直到队列再次有足够的空间。 如果消息是可延迟的取决于输入。 例如，通过imtcp收到的消息是可延迟的（因为TCP可以推回），但是通过imudp收到的消息不是（因为UDP不允许推回）。 这个设置背后的意图是在非延迟消息的几乎完整队列中留出一些空间，如果队列空间不足将会丢失。 请注意，如果您使用DA队列，则在高水位标记之后设置完全延迟标记将使队列永远不会为可延迟输入激活磁盘模式。 所以这可能不是你想要的。 队列大小的默认值为97％</p><ul><li>queue.lightdelaymark  number</li></ul><p>默认70％的队列大小</p><ul><li>queue.discardmark  number</li></ul><p>默认80％的队列大小</p><ul><li>queue.discardseverity</li></ul><p>number <em>numerical</em> severity! default 8 (nothing discarded)</p><ul><li>queue.checkpointinterval number</li></ul><p>每次队列写入磁盘时，默认情况下磁盘队列都不会更新管家结构。 这是出于性能原因。 在发生故障的情况下，数据将会丢失（除非数据通过文件结构被破坏）。 但是，可以将磁盘队列设置为在检查点上记录簿记信息（每n个记录），以使得这也可以是超可靠的。 如果检查点间隔设置为1，则不会丢失数据，但队列速度异常缓慢。</p><ul><li>queue.syncqueuefiles on/off (default “off”)</li></ul><p>在每次写入操作之后，通过发出(f)sync，可以使基于磁盘的队列非常可靠。 将参数设置为“on”时会发生这种情况。 激活这个选项有一个性能损失，所以不应该没有很好的理由打开。 请注意，惩罚也取决于queue.checkpointInterval频率。</p><ul><li>queue.samplinginterval</li></ul><p>此选项允许队列由特定间隔产生的事件填充。 它提供了一种对每个N个事件进行数据采样的方法，而不是全部处理，以减少资源使用（磁盘，带宽…）。此功能适用于8.23及更高版本。</p><ul><li>queue.type</li></ul><p>[FixedArray/LinkedList/Direct/Disk]</p><ul><li>queue.workerthreads number</li></ul><p>工作线程数，默认为1，建议1</p><ul><li>queue.timeoutshutdown number</li></ul><p>超时时间，单位ms（1000ms为1秒！），默认为0（不限制）</p><ul><li>queue.timeoutactioncompletion number</li></ul><p>超时时间，单位ms（1000ms为1秒！），默认为1000，0表示不限制</p><ul><li>queue.timeoutenqueue number</li></ul><p>超时时间，单位ms（1000ms为1秒！），默认为2000，0表示不限制<br>队列满时使用此超时值。 如果rsyslog在超时时间内不能排队消息，则消息被丢弃。 请注意，这是最后的设置（假设默认值用于队列设置或设置了适当的参数）：所有可延迟的输入（如imtcp或imfile）在此阶段已被推回。 此外，丢弃较低优先级的消息（如果已配置）已经发生。 所以如果我们没有足够快的超时，我们会遇到这样的情况之一：</p><ol><li>如果使用imuxsock并且不涉及systemd日志，则系统将变得无响应，并且很可能需要硬复位。</li><li>如果使用带有imjournal转发的imuxsock是活动的，则由于日志丢弃它们而丢失消息（比rsyslog更具侵略性）</li><li>如果使用imjournal，日志将缓冲消息。 如果日志耗尽配置的空间，则消息将被丢弃。 所以在这种模式下丢弃被移到稍后的地方。</li><li>其他不可延迟的来源，如imudp也将失去信息所以提供这个设置是为了防止有问题的情况，这总是会导致消息丢失或系统挂起。对于行动队列，人们可能会争论是否更好地快速溢出到主队列。 如果需要的话，通过设置一个非常大的超时值，这很容易实现。 当然，主队列也是如此，但是如果你这样做的话，你已经被警告过了！</li></ol><p> 换句话说，您可以使用默认值来考虑这种情况。 所有进度被阻止（无法传递讯息）：</p><ol><li><p>所有可延迟的输入（tcp，relp，imfile，imjournal等）将会无限制地阻塞（假设queue.lightdelaymark和queue.fulldelaymark被设置为合理的，这是默认的）。</p></li><li><p>imudp将失去消息，因为操作系统将放弃他们</p></li><li><p>通过UDP或imuxsock到达rsyslog的消息，并且严重程度足以使其不被discardseverity过滤，将阻塞2秒，试图将消息放入队列中（希望发生某些事情可以使空间 在队列中），然后放下，以避免永久阻塞机器。</p></li></ol><p>然后下一条待处理的消息也会被尝试2秒等等</p><ol><li>如果进入动作队列，日志消息将在这2秒钟内保持在主队列中，而到达的其他日志则会在主队列中累积。</li></ol><ul><li>queue.timeoutworkerthreadshutdown  number</li></ul><p>超时时间，单位ms（1000ms为1秒！），默认为60000（1分钟）</p><ul><li>queue.workerthreadminimummessages </li></ul><p>number default queue size/number of workers</p><ul><li>queue.maxfilesize</li></ul><p>size_nbr default 1m</p><ul><li>queue.saveonshutdown  on/<strong>off</strong></li><li>queue.dequeuetimebegin </li></ul><p>单位微秒（1000000us是1秒！），默认为0（无延迟）。 简单的限速！</p><ul><li>queue.dequeuetimeend  number</li><li>queue.samplinginterval number</li></ul><p>动作队列的采样间隔。 此参数指定在排入队列之前将丢弃多少行日志。 默认为0。</p><p>例子：</p><p>以下是带有自己的队列的TCP转发操作示例。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">action(<span class="attribute">type</span>=<span class="string">"omfwd"</span> <span class="attribute">target</span>=<span class="string">"192.168.2.11"</span> <span class="attribute">port</span>=<span class="string">"10514"</span> <span class="attribute">protocol</span>=<span class="string">"tcp"</span></span><br><span class="line">       queue.<span class="attribute">filename</span>=<span class="string">"forwarding"</span> queue.<span class="attribute">size</span>=<span class="string">"1000000"</span> queue.<span class="attribute">type</span>=<span class="string">"LinkedList"</span></span><br><span class="line">      )</span><br></pre></td></tr></table></figure><h4 id="The-rsyslog-“call”-statement"><a href="#The-rsyslog-“call”-statement" class="headerlink" title="The rsyslog “call”  statement"></a>The rsyslog “call”  statement</h4><p>rsyslog“call”语句用于将规则集绑定在一起。它是按照通常的编程语言“调用”语句建模的。把一个规则集想象成一个子程序（它到底是什么！），你就可以得到这个图像。</p><p>“call”语句可用于调用任何类型的规则集。如果规则集分配了队列，则消息将被发送到该队列并异步处理。否则，在规则集执行完成后，规则集将被同步执行，控制权在调用后立即返回。</p><p>请注意，对于“停止”语句，异步执行和同步执行之间存在重要区别。在异步运行时不会影响原始消息的处理。</p><p>“call”语句取代了不推荐的omruleset模块。它提供omruleset具有的所有功能，但以更高效的方式工作。请注意，omruleset是在v7之前的引擎的限制内调用规则集的一种破解。 “呼叫”是新引擎的干净解决方案。特别是对于没有关联队列（同步操作）的规则集，它没有开销（真的！）。 omruleset总是需要重复消息，通常意味着至少〜250字节的内存写入，一些分配和释放 - 以及更多的性能密集型操作。</p><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">call</span> rulesetname</span><br></pre></td></tr></table></figure><p>其中“rulesetname”是在配置中其他位置定义的规则集的名称。 如果调用是同步的还是异步取决于规则集参数。 这不能被“调用”语句覆盖。</p><h5 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h5><p>Blog posting announcing “call” statement (with sample)</p><p><a href="http://blog.gerhards.net/2012/10/how-to-use-rsyslogs-ruleset-and-call.html" target="_blank" rel="noopener">http://blog.gerhards.net/2012/10/how-to-use-rsyslogs-ruleset-and-call.html</a></p><h4 id="The-rsyslog-“call-indirect”-statement"><a href="#The-rsyslog-“call-indirect”-statement" class="headerlink" title="The rsyslog “call_indirect” statement"></a>The rsyslog “call_indirect” statement</h4><p>rsyslog“call_indirect”语句等价于“call”语句，不同的是被调用的规则集的名称不是常量，而是表达式，因此可以在运行时计算。</p><p>如果使用call_indirect时无法找到规则集名称，则会发出错误消息，并忽略call_indirect语句。 执行继续下一个语句。</p><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_indirect expression<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>“expression”是任何有效的表达是。 请参阅表达式了解更多信息 请注意，后缀分号需要指示表达式的结尾。 如果没有给出，配置加载将失败并出现语法错误消息</p><h5 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h5><p>“call_indirect”潜在最有用的用例是基于消息变量调用规则集。 让我们假设您已经根据预期的系统日志标记命名了您的规则集。 那么你可以使用</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_indirect <span class="variable">$ </span>syslogtag;</span><br></pre></td></tr></table></figure><p>调用这些规则集。 但是，请注意，这可能会被恶意攻击者滥用，攻击者将注入无效的系统日志标记。 这尤其可以用来将消息流重定向到已知的标准规则集。 为了减轻这一点，规则集名称可以通过创建一个唯一的前缀（不要使用这个示例中的一个）稍微改变。 让我们假定使用前缀“changeme-”，那么所有的规则集应该以该字符串开始。 然后，可以使用以下呼叫：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_indirect“changeme-”＆<span class="variable">$ </span>syslogtag;</span><br></pre></td></tr></table></figure><p>虽然可以通过常量名称调用规则集：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_indirect“my_ruleset”<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>建议使用“call”语句，因为在这种情况下它提供了优越的性能。</p><h5 id="附件信息"><a href="#附件信息" class="headerlink" title="附件信息"></a>附件信息</h5><p>我们需要有两个不同的语句，“call”和“call_indirect”，因为在添加“call_indirect”时已经存在“call”。 我们无法扩展“call”来支持表达式，因为这会破坏现有的配置。 在这种情况下，调用规则集将会失效，而调用“规则集”将不得不被使用。 因此，我们决定为这个用例添加额外的“call_indirect”语句。</p><h4 id="global-configuration-object"><a href="#global-configuration-object" class="headerlink" title="global() configuration object"></a>global() configuration object</h4><p>全局配置对象允许设置全局参数。 请注意，每个参数只能设置一次，以后不能重新设置。 如果一个参数设置多次，行为是不可预知的。<br>以下参数可以设置：</p><ul><li>action.reportSuspension - binary, default “on”, v7.5.8+</li></ul><p>如果启用（“on”）action 将在syslog.*下记录消息，当一个action暂停或恢复时。 通常连接到后端系统出现问题时，会发生这种情况。 如果禁用（“关闭”），则不会生成这些消息。 这些消息可以用于检测后端系统的问题。 最重要的是，频繁的暂停和恢复指向一个问题领域</p><ul><li>action.reportSuspensionContinuation - binary, default “off”, v7.6.1+, v8.2.0+</li></ul><p>如果启用（“开”），该action不仅仅报告第一次暂停，但是每次暂停被延长。 否则，后续消息不会被记录。如果此设置设置为“on”，则action.reportSuspension也会自动打开为“on”。</p><ul><li><p>workDirectory</p></li><li><p>dropMsgsWithMaliciousDNSPtrRecords</p></li><li><p>localHostname</p></li><li><p>preserveFQDN</p></li><li><p>defaultNetstreamDriverCAFile</p></li></ul><p>对于TLS系统日志，可以验证机器密钥和证书的CA证书（请参见下文）</p><ul><li>defaultNetstreamDriverKeyFile</li></ul><p>机器私钥</p><ul><li>defaultNetstreamDriverCertFile</li></ul><p>机器公钥</p><ul><li>debug.gnutls (0-10; default:0)</li></ul><p>除0以外的任何其他参数都会启用GnuTLS的调试消息。 给出的消息数量取决于参数的高度，0没有任何意义，10是非常多的。 警告！ 更高的参数可能会给出比需要更多的信息。 我们建议您首先使用小参数来防止发生。 如果启用通用调试，此参数仅起作用。</p><ul><li>processInternalMessages binary (on/off)</li></ul><p>这告诉rsyslog是否应该处理内部消息本身。 默认的操作模式（“关”）使rsyslog发送消息到系统日志接收器（如果它是唯一的实例，从那里接收它们）。 这也适用于systemd日志，并会使rsyslog消息显示在systemd状态控制信息中。</p><p>如果rsyslog的这个（实例）不是主实例，并且有另一个主要的日志系统，rsyslog内部消息将被插入到主实例的系统日志流中。 在这种情况下，设置为（“on”）将使您能够接收来自其实例的内部消息。</p><p>请注意，早期版本的rsyslog工作方式相反。 有关更改的更多信息可以在rsyslog-error-reporting-improved中找到。</p><ul><li>stdlog.channelspec</li></ul><p>允许设置liblogging-stdlog通道说明符字符串。 这又允许发送rsyslog日志消息到不同于系统默认值的目的地。 请注意，只有在processInternalMessages设置为“off”的情况下，此参数才有效。 否则，它会被默默地忽略。</p><ul><li>defaultNetstreamDriver</li></ul><p>设置”gtls”,开启TLS<br>Set it to “gtls” to enable TLS for TLS syslog</p><ul><li>maxMessageSize</li></ul><p>rsyslog可以处理的最大消息大小。 默认值是8K。 超过最大尺寸的任何内容都将被截断。</p><ul><li>janitor.interval [minutes], available since 8.3.3</li></ul><p>设置管理员进程运行的时间间隔。</p><ul><li>debug.onShutdown available in 7.5.8+</li></ul><p>如果启用（“on”），rsyslog将在请求系统关闭时记录调试消息。 这可以用来跟踪仅在关机期间发生的问题。 在正常操作期间，系统性能不受影响。 请注意，为使此选项有用，还必须设置debug.logFile参数（或相应的环境变量）。</p><ul><li>debug.logFile available in 7.5.8+</li></ul><p>这用于指定调试日志文件名称。 它用于所有调试输出。 请注意，RSYSLOG_DEBUGLOG环境变量总是重写debug.logFile的值。</p><ul><li>net.ipprotocol available in 8.6.0+</li></ul><p>这允许指示rsyslog仅使用IPv4或IPv6。 可能的值是“未指定的”，在这种情况下，使用两种协议，“ipv4-only”和“ipv6-only”，它们限制使用指定的协议。 默认是“未指定”。</p><p>注意：这取代了以前的-4和-6 rsyslogd命令行选项。</p><ul><li>net.aclAddHostnameOnFail available in 8.6.0+</li></ul><p>如果“启用”，在ACL处理期间，出于性能原因，主机名被解析为IP地址。 如果在这个过程中DNS失败，主机名将被添加为通配符文本，一旦DNS重新启动，这将导致适当的，但稍慢的操作。</p><p>默认是“关”。</p><ul><li>net.aclResolveHostname available in 8.6.0+</li></ul><p>如果“关闭”，则在ACL处理期间不要将主机名解析为IP地址。</p><p>默认开启</p><ul><li>net.enableDNS [on/off] available in 8.6.0+</li></ul><p>默认开启</p><p>可以用来打开或关闭DNS名称解析。</p><ul><li>net.permitACLWarning [on/off] available in 8.6.0+</li></ul><p>默认开启</p><p>如果“关闭”，则禁止从未授权的机器（不在AllowedSender列表中）收到消息时发出的警告。</p><ul><li>parser.parseHostnameAndTag [on/off] available in 8.6.0+</li></ul><p>默认值：打开</p><p>这控制解析器试图解析来自消息的HOSTNAME和TAG字段。 默认是“开”，在这种情况下解析发生。 如果设置为“关”，则不解析这些字段。 请注意，这通常不是你想要的。</p><p>强烈建议只有当你确切知道你为什么这样做时，才能将此设置更改为“关闭”。</p><ul><li>parser.permitSlashInHostname [on/off] available in 8.25.0+</li></ul><p>默认：关闭</p><p>这将控制是否允许在“程序名”属性中使用斜杠。 这个属性基于BSD概念，通过BSD syslogd源，在程序名称中不允许斜线。 但是，一些Linux工具（包括最重要的日志）在syslogtag中存储斜杠作为程序名称的一部分。 在这种情况下，程序名会在第一个斜杠处截断。 如果此设置更改为“开”，则允许斜线，并且不会终止程序名解析。</p><ul><li>parser.permitSlashInProgramName [on/off] available in 8.25.0+</li></ul><p>默认：关闭</p><p>这将控制是否允许标签的静态部分中的斜杠。 如果该设置关闭，则标签中的值“app/foo [1234]”将解析程序名为“app”。 如果应用程序存储绝对路径名称，例如“/app/foo [1234]”，则programname属性将变为空（“”）。 如果您需要将斜线实际存储为程序名称的一部分，则应将此设置更改为“打开”以允许此设置。 然后，“/app/foo[1234]”的syslog标签将导致程序名为“/app/foo”。</p><ul><li>senders.keepTrack [on/off] available 8.17.0+</li></ul><p>默认：关闭</p><p>如果打开，rsyslog跟踪已知的发件人，并通过impstats机制报告他们的统计数据。</p><p>保存活动发件人列表。 当检测到新的发件人时，会发出信息性消息。 只有在超时后才能从列表中清除发件人（请参阅senders.timoutAfter参数）。 请注意，当连接关闭时，我们不会有意删除发件人。 发件人跟踪的重点在于能够提供更长时间的数据。 因此，我们不希望仅仅因为发送者已经在短时间内断开（例如，重新启动）而丢弃信息。</p><p>发件人通过主机名进行跟踪（在连接建立时）。</p><p>注意：目前只有imptcp和imtcp支持发件人跟踪。</p><ul><li>enders.timeoutAfter [seconds] available 8.17.0+</li></ul><p>默认：12小时（12 <em> 60 </em> 60秒）</p><p>指定发送者在哪段时间后被认为“已经离开”。 对于每个发件人，rsyslog都会记录最少收到的邮件的时间。 如果在该时间间隔内没有收到消息，则rsyslog会认为发送者不再存在。 然后它将a）发出警告信息（如果已配置）并且b）从主动发送者列表中清除它。 因此，一旦发送数据超时，发件人将不再被报告。</p><ul><li>senders.reportGoneAway [on/off] available 8.17.0+</li></ul><p>默认：关闭</p><p>当发送者在发送者的时间间隔内已经接收到来自发送者的数据时，发出警告消息。</p><ul><li>senders.reportNew [on/off] available 8.17.0+</li></ul><p>默认：关闭</p><p>如果发件人跟踪处于活动状态，请报告尚未在缓存中的发件人。 请注意，这意味着由于长时间不活动而超时的发件人在重新连接后也会被报告。</p><ul><li>debug.unloadModules [on/off] available 8.17.0+</li></ul><p>默认值：打开</p><p>这主要是一个调试设置。 如果设置为“off”，rsyslog永远不会卸载任何模块（包括插件）。 这通常不会导致操作上的问题，但在极端的情况下可能会发生 这个设置的核心好处是它使valgrind堆栈跟踪可读。 在以前的版本中，只有通过特殊的构建选项才能使用相同的功能。</p><ul><li>debug.files [ARRAY of filenames] available 8.29.0+</li></ul><p>默认值：无</p><p>这可以用来配置rsyslog只显示在某些文件中生成的调试输出。 如果该选项已设置，但没有给出文件名，则调试输出的行为就像关闭该选项一样。</p><p>但请注意，由于配置的工作方式，这可能不会影响前几个调试输出，而rsyslog正在读取配置。 为了达到最佳效果，我们建议在配置的最初阶段将此参数设置为最小化不需要的输出。</p><p>有关更多信息，请参阅debug.whitelist。</p><ul><li>debug.whitelist [on/off] available 8.29.0+</li></ul><p>默认值：打开</p><p>该参数是debug.files的辅助参数。 如果在配置中使用了debug.files，那么debug.whitelist是一个开关，用于从显示调试输出中命名为白名单或黑名单的文件。 如果它被设置为打开，列出的文件将生成调试输出，但不会有其他文件。 如果参数设置为关，则反向原则适用。</p><p>有关更多信息，请参阅debug.files。</p><ul><li>environment [ARRAY of environment variable=value strings] available 8.23.0+</li></ul><p>默认值：无</p><p>这允许通过rsyslog.conf设置环境变量。 这样做的主要动机是，对于许多库，默认值可以通过环境变量来设置，但是通过操作系统服务启动文件来设置它们在不同的平台上是很麻烦和不同的。 所以环境参数提供了一个方便的方法来设置这些变量。</p><p>一个常见的例子是设置http_proxy变量，例如 用于KSI签名或ElasticSearch。 这可以如下完成：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">global</span><span class="params">(environment=<span class="string">"http_proxy=http://myproxy.example.net"</span>)</span></span></span><br></pre></td></tr></table></figure><p>请注意，以这种方式设置的环境变量必须包含等号，并且变量名称不得超过127个字符。</p><p>可以在单个全局语句中设置多个环境变量。 这是用常规的数组语法完成的，如下所示：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global<span class="params">(<span class="attr">environment</span>=["<span class="attr">http_proxy</span>=http://myproxy.example.net",</span></span><br><span class="line"><span class="params">                    "<span class="attr">another_one</span>=this string <span class="attr">is</span>=ok!"</span></span><br><span class="line"><span class="params">      )</span></span><br></pre></td></tr></table></figure><p>像往常一样，空白在参数放置方面是不相关的。 所以上面的例子也可以写在一行上。</p><ul><li>internalmsg.ratelimit.interval [positive integer] available 8.29.0+</li></ul><p>默认：5</p><p>指定将速率限制应用于由rsyslog生成的内部信息包（即错误信息）的时间间隔（以秒为单位）。 如果在该时间间隔内读取超过internalmsg.ratelimit.burst消息，则直至间隔结束的更多消息将被丢弃。</p><ul><li>internalmsg.ratelimit.burst [positive integer] available 8.29.0+</li></ul><p>Default: 500</p><p>指定将速率限制应用于由rsyslog生成的内部信息包（即错误信息）的时间间隔（以秒为单位）。 如果在该时间间隔内读取超过internalmsg.ratelimit.burst消息，则直至间隔结束的更多消息将被丢弃。</p><p>警告：遇到相应的语句时立即设置环境变量。 同样，模块在遇到模块加载语句时加载。 这可能会在rsyslog.conf中创建序列依赖关系。 为避免这种情况，强烈建议在rsyslog.conf的顶部设置环境变量。 而且，rsyslog相关的环境变量可能不适用，即使设置在顶部。 仍然将它们设置在操作系统启动文件中是最安全的。 请注意，rsyslog环境变量通常仅用于开发人员，因此几乎不需要为普通用户设置它们。 而且，许多设置（例如调试）也可用作配置对象。</p><ul><li>errorMessagesToStderr.maxNumber [positive integer] available 8.30.0+</li></ul><p>默认：不限制</p><p>这允许对可以进入标准错误的消息的数量进行严格的限制。 如果没有别的，这个功能对测试平台是有帮助的。 它允许减少垃圾邮件的测试日志，同时仍然提供查看初始错误消息的能力。 对于一些实际的部署可能也是有用的。</p><ul><li>variables.caseSensitve [boolean (on/off)] available 8.30.0+</li></ul><p>默认：关闭</p><p>这可以使变量区分大小写，对于一些特殊的输入数据可能需要哪些情况，只是字段名称的唯一区别。 请注意，在8.30之前的rsyslog版本中，缺省值为“on”，这经常导致用户混淆。 除了需要提及的情况之外，通常不需要将其切换回“开”。 这也是我们切换默认的原因。</p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2016/10/07/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-RainerScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Rsyslog-v8学习笔记六(过滤条件)</title>
      <link>http://blog.loveops.com/2016/10/06/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/</link>
      <guid>http://blog.loveops.com/2016/10/06/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/</guid>
      <pubDate>Thu, 06 Oct 2016 10:27:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;过滤条件&quot;&gt;&lt;a href=&quot;#过滤条件&quot; class=&quot;headerlink&quot; title=&quot;过滤条件&quot;&gt;&lt;/a&gt;过滤条件&lt;/h3&gt;&lt;p&gt;Rsyslog 提供四种类型的过滤条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“traditional” severity and f
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h3><p>Rsyslog 提供四种类型的过滤条件：</p><ul><li>“traditional” severity and facility based selectors（根据优先级和设施）</li><li>property-based filters </li><li>expression-based filters</li><li>BSD-style blocks (not upward compatible)</li></ul><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>选择器是过滤系统日志消息的传统方式。它们被保留在rsyslog中，因为他们的原始语法是众所周知的，高效的，也需要与stock   syslogd配置文件兼容。如果您只需要根据优先级和设施进行筛选，则应该使用选择器线进行筛选。 它们为这项工作提供了最好的表现。</p><p>选择器字段本身又由两部分组成，一个设施和一个优先级，由点号（“.”）隔开。这两个部分不区分大小写，也可以指定为十进制数字，但是最好不药这样做，会有警告信息 syslog（3）中描述了设施和优先级。下面提到的名称对应于/usr/include/syslog.h中类似的LOG_values。</p><p>设施必须是以下关键字之一：</p><ul><li>auth </li><li>authpriv </li><li>cron </li><li>daemon</li><li>kern </li><li>lpr</li><li>mail </li><li>mark</li><li>news</li><li>security (same as auth)</li><li>syslog</li><li>user</li><li>uucp</li><li>local0-local7<br>关键字security不应该再使用，mark仅供内部使用，因此不应在应用程序中使用。 无论如何，你可能想在这里指定和重定向这些消息。该工具指定产生该消息的子系统，即，如果使用syslog登录，则所有的邮件程序都将使用邮件工具（LOG_MAIL）进行登录。</li></ul><p>优先级是以下关键字之一，按升序排列：</p><ul><li>debug</li><li>info</li><li>notice</li><li>warning</li><li>warn（与warning相同）</li><li>err</li><li>error（与err相同</li><li>cirt</li><li>alter</li><li>emerg</li><li>panic（与emerg相同）</li></ul><p>关键字error、 warn and panic已被弃用，不应再使用。 优先级定义了消息的严重程度。</p><p>原BSD syslogd的行为是根据给定的动作记录所有指定优先级和更高优先级的消息。 Rsyslogd表现相同，但有一些扩展。</p><p>除上述名称外，rsyslogd（8）还可以理解以下扩展：星号（“*”）代表所有设施或所有优先级，具体取决于它在何处使用（在期间之前或之后）。 关键字none表示给定设施没有优先权。 您可以使用逗号（“，”）运算符在一个语句中指定具有相同优先级模式的多个工具。 你可以指定尽可能多的需要的设施。请记住，只有来自这样的声明的设施部分被采取，优先部分将被跳过。</p><p>可以使用分号（“;”）分隔符为单个动作指定多个选择器。 请记住，选择器字段中的每个选择器都可以覆盖前面的选择器。 使用这种行为，你可以从模式中排除一些优先级。</p><p>Rsyslogd具有原始BSD源语法扩展，使其更直观。 您可以在每个优先级之前加上等号（“=”）来指定这个优先级，而不是上面的任何一个。 你也可以（都是有效的）在优先级之前用一个感叹号（“！”）来忽略所有的优先级，或者确切地说这个或者这个以及任何更高的优先级。 如果您使用两个扩展名，而感叹号必须在等号之前出现，请直观地使用它。</p><h4 id="基于属性的过滤器"><a href="#基于属性的过滤器" class="headerlink" title="基于属性的过滤器"></a>基于属性的过滤器</h4><p>基于属性的过滤器对rsyslogd是唯一的。 他们允许过滤任何属性，如HOSTNAME，syslogtag和msg。 所有当前支持的属性的列表可以在property replacer documentation中找到（但请记住只有属性，而不支持替换器）。 使用此过滤器，可以使用指定的比较操作，针对指定的值检查每个属性。</p><p>基于属性的过滤器必须以冒号开头。这告诉rsyslogd它是新的过滤器类型。 冒号后面必须跟着属性名称，逗号，比较操作的名称执行，另一个逗号，然后是比较的值。 这个值必须被引用。 逗号之间可以有空格和制表符。 属性名称和比较操作区分大小写，所以“msg”起作用，而“MSG”是一个无效的属性名称。 简言之，语法如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">property</span><span class="title"></span>, [!]compare-operation, <span class="string">"value"</span></span><br></pre></td></tr></table></figure><h4 id="比较的操作"><a href="#比较的操作" class="headerlink" title="比较的操作"></a>比较的操作</h4><p>目前支持以下比较操作：</p><ul><li>contains</li></ul><p>检查字符串中是否包含指定的值。 必须有完全匹配，不支持通配符。</p><ul><li>sequal</li></ul><p>比较提供的“值”字符串和属性内容是否完全相等。 与contains的区别在于包含只要在属性值内任何位置搜索到即可，而对于isequal必须是王权相同的。 因此，isequal对于像syslogtag或者FROMHOST这样的领域是非常有用的，你可能知道确切的内容。</p><ul><li>startswith</li></ul><p>检查指定值是否刚好是属性值的开始。 例如，如果您搜索“val”</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:msg</span>, startswith, <span class="string">"val"</span></span><br></pre></td></tr></table></figure><p>“values are in this message”将匹配到，而“There are values in this message”将匹配不到，但是后者能匹配“contains”。<br>请注意，“startswith”比正则表达式要快得多。 所以即使一旦实施，使用“startswith”也可能会有很大的意义（性能方面）。</p><ul><li>regex<br>将该属性与提供的POSIX BRE正则表达式进行比较。</li><li>ereregex<br>将该属性与提供的POSIX ERE正则表达式进行比较。</li></ul><p>你可以在比较操作之前使用感叹号（！），这个操作的结果是否定的。 例如，如果msg包含“This is a informative message”，下面的示例将不匹配：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:msg, <span class="keyword">contains</span>, <span class="string">"error"</span></span><br></pre></td></tr></table></figure><p>这个是匹配的:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:msg, !<span class="keyword">contains</span>, <span class="string">"error"</span></span><br></pre></td></tr></table></figure><p>如果您想要进行一些通用处理但排除某些特定事件，则使用否定可能很有用。 您可以结合使用丢弃操作。 比如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.* /var/<span class="built_in">log</span>/allmsgs-including-informational.<span class="built_in">log</span></span><br><span class="line">:msg, <span class="keyword">contains</span>, <span class="string">"informational"</span>  ~</span><br><span class="line">*.* /var/<span class="built_in">log</span>/allmsgs-<span class="keyword">but</span>-informational.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>不要忽略第2行的”~”符号, 在这个例子中，所有的消息都被写入文件allmsgs-including-informational.log。 然后，包含字符串“informational”的所有消息都被丢弃。 这意味着“丢弃行”下方的配置文件行（我们示例中的编号2）将不会应用于此消息。 然后，所有剩余的行也将写入文件allmsgs-but-informational.log。</p><h4 id="Value-Part"><a href="#Value-Part" class="headerlink" title="Value Part"></a>Value Part</h4><p>值是一个带引号的字符串。 它支持一些转义序列：</p><p>\” - 双引号 (e.g. “String with \”Quotes\””)<br>\ - 反斜线 (e.g. “C:\tmp”)<br>转义序列始终以反斜杠开始。 反斜杠字符必须转义。 那么上面列出的任何其他序列是无效的，并可能导致不可预知的结果。</p><p>可能“msg”是基于属性过滤器最突出的用例。 这是实际的消息文本。 如果您想根据某些消息内容（例如特定代码的存在）进行过滤，则可以通过以下方式轻松完成此操作：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:msg, <span class="keyword">contains</span>, <span class="string">"ID-4711"</span></span><br></pre></td></tr></table></figure><p>当消息包含字符串“ID-4711”时，该过滤器将匹配。 请注意，比较区分大小写，所以如果消息中包含“id-4711”，则不匹配。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:msg</span>, regex, <span class="string">"fatal .* error"</span></span><br></pre></td></tr></table></figure><p>此过滤器使用POSIX正则表达式。 当字符串包含“fatal”和“error”之间的任何内容（例如e.g. “fatal net error” 和 “fatal lib error” 但是 “fatal error”不行，因为正则表达式需要两个空格！</p><p>正确获取基于属性过滤器有时可能具有挑战性。 为了帮助您尽可能地做到这一点，rsyslogd在评估过程中为所有基于属性的过滤器吐出调试信息。 要启用它，请在前台运行rsyslogd并指定“-d”选项。</p><p>基于属性的过滤器中目前不支持布尔运算‘message contains “ID17” or message contains “ID18”’）（除了上面的“not”外）。 请注意，虽然可以通过基于属性的过滤器来查询设施和严重性，但对于这些情况，使用经典选择器（参见上文）更为明智。</p><h4 id="基于表达式的筛选器"><a href="#基于表达式的筛选器" class="headerlink" title="基于表达式的筛选器"></a>基于表达式的筛选器</h4><p>基于表达式的过滤器允许对任意复杂表达式进行过滤，包括布尔，算术和字符串操作。 表达式过滤器将演变成完整的配置脚本语言。 不幸的是，他们的语法在这个过程中会稍微改变。 所以如果你现在使用它们，你需要准备在一段时间后改变你的配置文件。 但是，我们尽可能快地实施脚本功能（也就是所需的阶段性工作）。 所以曝光时间可能不会太长。</p><p>基于表达式的过滤器在新行的第1列中用关键字“if”表示。 他们有这样的格式：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expr <span class="keyword">then</span> action-part-<span class="keyword">of</span>-selector-<span class="built_in">line</span></span><br></pre></td></tr></table></figure><p>“if”和“then”是必须存在的固定关键字。 “expr”是一个（可能相当复杂的）表达式。 请查看expression documentation 。“action-part-of-selector-line”是一个动作，就像你所知道的那样（例如 “/var/log/logfile” to write to that file）。</p><h4 id="BSD风格-Blocks"><a href="#BSD风格-Blocks" class="headerlink" title="BSD风格 Blocks"></a>BSD风格 Blocks</h4><p>注意：由于技术原因，rsyslog v7 +不再支持BSD风格的blocks。所以强烈建议不要使用它们。</p><p>Rsyslogd在rsyslog.conf中支持BSD风格的blocks。通过程序或主机名规范将每一行的blocks与先前的blocks分离。一个blocks只会记录对应于给定的最新程序和主机名规范的消息。因此，一个选择“ppp”作为程序的blocks，紧接着是一个从主机名“dialhost”中选择消息的blcoks，然后第二个blocks将只在dialhost上记录来自ppp程序的消息。</p><p>程序规范是以’!prog’开始的行，下面的blocks将与来自该特定程序的syslog调用相关联。 “foo”的程序规范也将匹配内核记录的任何以“foo：”为前缀的消息。或者，程序规范“-foo”会使以下块应用于来自除指定程序之外的任何程序的消息。 “+ hostname”形式的主机名规范以及以下块将应用于从指定主机名接收到的消息。或者，主机名规范“-hostname”会使以下块应用于来自任何主机但指定的主机的消息。如果主机名称为“@”，则将使用本地主机名称。 （尚未实现）通过将程序或主机名称设置为“*”，可以重置程序或主机名称规范。</p><p>请注意，rsyslogd不支持BSD syslogd中的“#!prog”，“＃+ hostname”和“＃-hostname”语法。默认情况下，不设置主机名或程序。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.* /var/<span class="built_in">log</span>/file1 <span class="comment"># the traditional way</span></span><br><span class="line"><span class="keyword">if</span> $msg <span class="keyword">contains</span> '<span class="keyword">error</span>' <span class="keyword">then</span> /var/<span class="built_in">log</span>/errlog <span class="comment"># the expression-based way</span></span><br></pre></td></tr></table></figure><p>现在，如果您想检查设施和严重性，则需要指定数值。 这些可以在RFC 5424中找到。如果你不喜欢，你当然也可以使用文本属性 - 只要确保使用正确的。 随着表达的支持增强，这将会改变。 例如，如果要过滤具有设备local0的消息，请以“DEVNAME”开头，并在其消息内容中包含“error1”或“error0”，您可以使用以下过滤器：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> $syslogfacility-text == <span class="string">'local0'</span> <span class="literal">and</span> $msg startswith <span class="string">'DEVNAME'</span> <span class="literal">and</span> ($msg contains <span class="string">'error1'</span> <span class="literal">or</span> $msg contains <span class="string">'error0'</span>) <span class="keyword">then</span> /var/<span class="built_in">log</span>/somelog</span><br></pre></td></tr></table></figure><p>请注意，以上都必须在一行！ 如果你想存储除了那些包含“error1”或“error0”的消息，你只需要添加一个“not”：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> $syslogfacility-text == <span class="string">'local0'</span> <span class="literal">and</span> $msg startswith <span class="string">'DEVNAME'</span> <span class="literal">and</span> <span class="literal">not</span> ($msg contains <span class="string">'error1'</span> <span class="literal">or</span> $msg contains <span class="string">'error0'</span>) <span class="keyword">then</span> /var/<span class="built_in">log</span>/somelog</span><br></pre></td></tr></table></figure><p>如果您想进行不区分大小写的比较，请使用“contains_i”和“startswith_i”而不是“contains”和“startswith”。 请注意，基于表达式的过滤器目前不支持正则表达式。 当函数支持被添加到表达式引擎时，这些将被添加（原因是正则表达式将是一个单独的可加载模块，这需要更多的前提条件才能实现）。</p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2016/10/06/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Rsyslog-v8学习笔记五(Property Replacer不匹配模式)</title>
      <link>http://blog.loveops.com/2016/10/05/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-Property-Replacer%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://blog.loveops.com/2016/10/05/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-Property-Replacer%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Wed, 05 Oct 2016 10:25:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;Property-Replacer不匹配模式&quot;&gt;&lt;a href=&quot;#Property-Replacer不匹配模式&quot; class=&quot;headerlink&quot; title=&quot;Property Replacer不匹配模式&quot;&gt;&lt;/a&gt;Property Replacer不匹配
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="Property-Replacer不匹配模式"><a href="#Property-Replacer不匹配模式" class="headerlink" title="Property Replacer不匹配模式"></a>Property Replacer不匹配模式</h4><p>“不匹配模式”指定属性替换者应该返回哪个字符串，如果正则表达式没有找到搜索字符串。传统上，字符串“<strong>不匹配</strong>”被返回，但许多人抱怨这几乎是没有用的。不过，这种模式对于传统配置是“DFLT”的支持。</p><p>另外还有三种可能有用的模式：在一个（BLANK）中返回一个空白字符串。这对于将值插入数据库中是有用的，如果找不到表达式，则不应插入任何值。</p><p>类似的模式是返回字符串“0”的“ZERO”。这适用于数值。用例可能是基于防火墙规则记录流量日志，并通过正则表达式提取“字节传输”计数器。如果当前消息中没有“字节传输”计数器，则返回空字符串（数据库层可以变为零）可能是个好主意。</p><p>另一种模式是“FIELD”，其中返回完整的字段。这可能是有用的，如果没有匹配被认为是失败的，并且触发它的消息应该被记录。</p><p>如果有疑问，强烈建议使用rsyslog在线正则表达式检查器和生成器来查看这些选项的操作。使用该在线工具，您可以根据样本制作正则表达式并尝试不同的模式。</p><h4 id="不匹配模式摘要"><a href="#不匹配模式摘要" class="headerlink" title="不匹配模式摘要"></a>不匹配模式摘要</h4><table><thead><tr><th>Mode</th><th>Returned</th></tr></thead><tbody><tr><td>DFLT</td><td>“<strong>NO MATCH</strong>”</td></tr><tr><td>BLANK</td><td>“” (empty string)</td></tr><tr><td>ZERO</td><td>“0”</td></tr><tr><td>FIELD</td><td>full content of original field</td></tr></tbody></table><p>交互式工具： <a href="http://www.rsyslog.com/regex/" target="_blank" rel="noopener">http://www.rsyslog.com/regex/</a></p>]]></content:encoded>
      
      <comments>http://blog.loveops.com/2016/10/05/Rsyslog-v8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-Property-Replacer%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
